-e 
=== ./middleware/logger.go ===

package middleware

import (
	"fmt"
	"time"

	"github.com/gin-gonic/gin"
)

func LoggerMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		start := time.Now()
		path := c.Request.URL.Path
		method := c.Request.Method

		c.Next()

		latency := time.Since(start)
		status := c.Writer.Status()
		fmt.Printf("[%s] %s %s %d %v\n", time.Now().Format(time.RFC3339), method, path, status, latency)
	}
}
-e 
=== ./middleware/autrh.go ===

package middleware

import (
	"fxtrader/internal/config"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
)

func AdminAuthMiddleware(cfg *config.Config) gin.HandlerFunc {
	return func(c *gin.Context) {
		authHeader := c.GetHeader("Authorization")
		if authHeader == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header required"})
			c.Abort()
			return
		}

		parts := strings.SplitN(authHeader, " ", 2)
		if len(parts) != 2 || parts[0] != "Basic" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid authorization header"})
			c.Abort()
			return
		}

		credentials := strings.SplitN(parts[1], ":", 2)
		if len(credentials) != 2 {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials format"})
			c.Abort()
			return
		}

		if credentials[0] != cfg.AdminUser || credentials[1] != cfg.AdminPass {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
			c.Abort()
			return
		}

		c.Next()
	}
}
-e 
=== ./middleware/user_auth.go ===

package middleware

import (
	"fxtrader/internal/repository"
	"net/http"
	"strings"
	"time"

	"github.com/dgrijalva/jwt-go"
	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

var jwtSecret = []byte("your_jwt_secret_key")

func UserAuthMiddleware(userRepo repository.UserRepository) gin.HandlerFunc {
	return func(c *gin.Context) {
		authHeader := c.GetHeader("Authorization")
		if authHeader == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header required"})
			c.Abort()
			return
		}

		parts := strings.SplitN(authHeader, " ", 2)
		if len(parts) != 2 || parts[0] != "Bearer" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid authorization header; expected Bearer token"})
			c.Abort()
			return
		}

		tokenStr := parts[1]
		token, err := jwt.Parse(tokenStr, func(token *jwt.Token) (interface{}, error) {
			if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
				return nil, jwt.ErrSignatureInvalid
			}
			return jwtSecret, nil
		})
		if err != nil || !token.Valid {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or expired token"})
			c.Abort()
			return
		}

		claims, ok := token.Claims.(jwt.MapClaims)
		if !ok {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token claims"})
			c.Abort()
			return
		}

		userIDStr, ok := claims["user_id"].(string)
		if !ok {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid user ID in token"})
			c.Abort()
			return
		}

		userObjID, err := primitive.ObjectIDFromHex(userIDStr)
		if err != nil {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid user ID format"})
			c.Abort()
			return
		}

		user, err := userRepo.GetUserByID(userObjID)
		if err != nil || user == nil {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "User not found"})
			c.Abort()
			return
		}

		c.Set("user_id", userIDStr)
		c.Next()
	}
}

func GenerateJWT(userID string) (string, error) {
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"user_id": userID,
		"exp":     time.Now().Add(365 * 24 * time.Hour).Unix(),
		"iat":     time.Now().Unix(),
	})

	return token.SignedString(jwtSecret)
}
-e 
=== ./repository/user_repository.go ===

package repository

import (
	"context"
	"fxtrader/internal/models"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

type UserRepository interface {
	SaveUser(user *models.UserAccount) error
	GetUserByID(id primitive.ObjectID) (*models.UserAccount, error)
	GetUserByTelegramID(telegramID string) (*models.UserAccount, error)
}

type MongoUserRepository struct {
	collection *mongo.Collection
}

func NewUserRepository(client *mongo.Client, dbName, collectionName string) UserRepository {
	collection := client.Database(dbName).Collection(collectionName)
	return &MongoUserRepository{collection: collection}
}

func (r *MongoUserRepository) SaveUser(user *models.UserAccount) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	_, err := r.collection.InsertOne(ctx, user)
	return err
}

func (r *MongoUserRepository) GetUserByID(id primitive.ObjectID) (*models.UserAccount, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var user models.UserAccount
	err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&user)
	if err == mongo.ErrNoDocuments {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return &user, nil
}

func (r *MongoUserRepository) GetUserByTelegramID(telegramID string) (*models.UserAccount, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var user models.UserAccount
	err := r.collection.FindOne(ctx, bson.M{"telegram_id": telegramID}).Decode(&user)
	if err == mongo.ErrNoDocuments {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return &user, nil
}
-e 
=== ./repository/log_repository.go ===

package repository

import (
	"context"
	"fxtrader/internal/models"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

type LogRepository interface {
	SaveLog(log *models.LogEntry) error
	GetAllLogs() ([]*models.LogEntry, error)
	GetLogsByUserID(userID primitive.ObjectID) ([]*models.LogEntry, error)
}

type MongoLogRepository struct {
	collection *mongo.Collection
}

func NewLogRepository(client *mongo.Client, dbName, collectionName string) LogRepository {
	collection := client.Database(dbName).Collection(collectionName)
	return &MongoLogRepository{collection: collection}
}

func (r *MongoLogRepository) SaveLog(log *models.LogEntry) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	log.ID = primitive.NewObjectID()
	log.Timestamp = time.Now()
	_, err := r.collection.InsertOne(ctx, log)
	return err
}

func (r *MongoLogRepository) GetAllLogs() ([]*models.LogEntry, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var logs []*models.LogEntry
	cursor, err := r.collection.Find(ctx, bson.M{}, options.Find().SetSort(bson.M{"timestamp": -1}))
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)
	if err := cursor.All(ctx, &logs); err != nil {
		return nil, err
	}
	return logs, nil
}

func (r *MongoLogRepository) GetLogsByUserID(userID primitive.ObjectID) ([]*models.LogEntry, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var logs []*models.LogEntry
	cursor, err := r.collection.Find(ctx, bson.M{"user_id": userID}, options.Find().SetSort(bson.M{"timestamp": -1}))
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)
	if err := cursor.All(ctx, &logs); err != nil {
		return nil, err
	}
	return logs, nil
}
-e 
=== ./repository/symbol_repository.go ===

package repository

import (
	"context"
	"fxtrader/internal/models"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

type SymbolRepository interface {
	SaveSymbol(symbol *models.Symbol) error
	GetSymbolByID(id primitive.ObjectID) (*models.Symbol, error)
	GetAllSymbols() ([]*models.Symbol, error)
	UpdateSymbol(id primitive.ObjectID, symbol *models.Symbol) error
	DeleteSymbol(id primitive.ObjectID) error
}

type MongoSymbolRepository struct {
	collection *mongo.Collection
}

func NewSymbolRepository(client *mongo.Client, dbName, collectionName string) SymbolRepository {
	collection := client.Database(dbName).Collection(collectionName)
	return &MongoSymbolRepository{collection: collection}
}

func (r *MongoSymbolRepository) SaveSymbol(symbol *models.Symbol) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	symbol.ID = primitive.NewObjectID()
	symbol.CreatedAt = time.Now()
	symbol.UpdatedAt = time.Now()
	_, err := r.collection.InsertOne(ctx, symbol)
	return err
}

func (r *MongoSymbolRepository) GetSymbolByID(id primitive.ObjectID) (*models.Symbol, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var symbol models.Symbol
	err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&symbol)
	if err == mongo.ErrNoDocuments {
		return nil, nil
	}
	return &symbol, err
}

func (r *MongoSymbolRepository) GetAllSymbols() ([]*models.Symbol, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var symbols []*models.Symbol
	cursor, err := r.collection.Find(ctx, bson.M{})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)
	if err := cursor.All(ctx, &symbols); err != nil {
		return nil, err
	}
	return symbols, nil
}

func (r *MongoSymbolRepository) UpdateSymbol(id primitive.ObjectID, symbol *models.Symbol) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	symbol.UpdatedAt = time.Now()
	update := bson.M{"$set": symbol}
	_, err := r.collection.UpdateOne(ctx, bson.M{"_id": id}, update)
	return err
}

func (r *MongoSymbolRepository) DeleteSymbol(id primitive.ObjectID) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	_, err := r.collection.DeleteOne(ctx, bson.M{"_id": id})
	return err
}
-e 
=== ./repository/rule_repository.go ===

package repository

import (
	"context"
	"fxtrader/internal/models"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

type RuleRepository interface {
	SaveRule(rule *models.Rule) error
	GetRuleByID(id primitive.ObjectID) (*models.Rule, error)
	GetAllRules() ([]*models.Rule, error)
	UpdateRule(id primitive.ObjectID, rule *models.Rule) error
	DeleteRule(id primitive.ObjectID) error
}

type MongoRuleRepository struct {
	collection *mongo.Collection
}

func NewRuleRepository(client *mongo.Client, dbName, collectionName string) RuleRepository {
	collection := client.Database(dbName).Collection(collectionName)
	return &MongoRuleRepository{collection: collection}
}

func (r *MongoRuleRepository) SaveRule(rule *models.Rule) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	rule.ID = primitive.NewObjectID()
	rule.CreatedAt = time.Now()
	_, err := r.collection.InsertOne(ctx, rule)
	return err
}

func (r *MongoRuleRepository) GetRuleByID(id primitive.ObjectID) (*models.Rule, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var rule models.Rule
	err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&rule)
	if err == mongo.ErrNoDocuments {
		return nil, nil
	}
	return &rule, err
}

func (r *MongoRuleRepository) GetAllRules() ([]*models.Rule, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var rules []*models.Rule
	cursor, err := r.collection.Find(ctx, bson.M{})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)
	if err := cursor.All(ctx, &rules); err != nil {
		return nil, err
	}
	return rules, nil
}

func (r *MongoRuleRepository) UpdateRule(id primitive.ObjectID, rule *models.Rule) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	update := bson.M{"$set": bson.M{"content": rule.Content}}
	_, err := r.collection.UpdateOne(ctx, bson.M{"_id": id}, update)
	return err
}

func (r *MongoRuleRepository) DeleteRule(id primitive.ObjectID) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	_, err := r.collection.DeleteOne(ctx, bson.M{"_id": id})
	return err
}
-e 
=== ./repository/trade_repository.go ===

package repository

import (
	"context"
	"fxtrader/internal/models"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

type TradeRepository interface {
	SaveTrade(trade *models.TradeHistory) error
	GetTradeByID(id primitive.ObjectID) (*models.TradeHistory, error)
	GetTradesByUserID(userID primitive.ObjectID) ([]*models.TradeHistory, error)
}

type MongoTradeRepository struct {
	collection *mongo.Collection
}

func NewTradeRepository(client *mongo.Client, dbName, collectionName string) TradeRepository {
	collection := client.Database(dbName).Collection(collectionName)
	return &MongoTradeRepository{collection: collection}
}

func (r *MongoTradeRepository) SaveTrade(trade *models.TradeHistory) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	trade.ID = primitive.NewObjectID()
	trade.OpenTime = time.Now()
	_, err := r.collection.InsertOne(ctx, trade)
	return err
}

func (r *MongoTradeRepository) GetTradeByID(id primitive.ObjectID) (*models.TradeHistory, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var trade models.TradeHistory
	err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&trade)
	if err == mongo.ErrNoDocuments {
		return nil, nil
	}
	return &trade, err
}

func (r *MongoTradeRepository) GetTradesByUserID(userID primitive.ObjectID) ([]*models.TradeHistory, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var trades []*models.TradeHistory
	cursor, err := r.collection.Find(ctx, bson.M{"_id": userID})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)
	if err := cursor.All(ctx, &trades); err != nil {
		return nil, err
	}
	return trades, nil
}
-e 
=== ./repository/price_repository.go ===

package repository

import (
	"fxtrader/internal/models"
	"sync"
)

type PriceRepository interface {
	SavePrice(data *models.PriceData) error
}

type InMemoryPriceRepository struct {
	prices []*models.PriceData
	mu     sync.Mutex
}

func NewPriceRepository() PriceRepository {
	return &InMemoryPriceRepository{
		prices: make([]*models.PriceData, 0),
	}
}

func (r *InMemoryPriceRepository) SavePrice(data *models.PriceData) error {
	r.mu.Lock()
	defer r.mu.Unlock()
	r.prices = append(r.prices, data)
	return nil
}
-e 
=== ./config/config.go ===

package config

import (
	"os"
	"strconv"

	"github.com/joho/godotenv"
)

type Config struct {
	Address   string
	Port      int
	BaseURL   string
	MongoURI  string
	AdminUser string
	AdminPass string
}

func Load() (*Config, error) {
	_ = godotenv.Load()

	portStr := os.Getenv("PORT")
	if portStr == "" {
		portStr = "8080"
	}

	port, err := strconv.Atoi(portStr)
	if err != nil {
		return nil, err
	}

	address := os.Getenv("ADDRESS")
	if address == "" {
		address = "0.0.0.0"
	}

	baseURL := os.Getenv("BASE_URL")
	if baseURL == "" {
		baseURL = "http://localhost:" + portStr
	}

	mongoURI := os.Getenv("MONGO_URI")
	if mongoURI == "" {
		mongoURI = "mongodb://127.0.0.1:27017"
	}

	adminUser := os.Getenv("ADMIN_USER")
	if adminUser == "" {
		adminUser = "admin"
	}

	adminPass := os.Getenv("ADMIN_PASS")
	if adminPass == "" {
		adminPass = "admin"
	}

	return &Config{
		Address:   address,
		Port:      port,
		BaseURL:   baseURL,
		MongoURI:  mongoURI,
		AdminUser: adminUser,
		AdminPass: adminPass,
	}, nil
}
-e 
=== ./config/admin.go ===

package config

import (
	"context"
	"fxtrader/internal/models"
	"fxtrader/internal/repository"
	"log"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"golang.org/x/crypto/bcrypt"
)

func EnsureAdminUser(userRepo repository.UserRepository, adminUser, adminPass string) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var user models.UserAccount
	err := userRepo.(*repository.MongoUserRepository).collection.FindOne(ctx, bson.M{"username": adminUser}).Decode(&user)
	if err == nil {
		log.Println("Admin user already exists")
		return nil
	}

	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(adminPass), bcrypt.DefaultCost)
	if err != nil {
		return err
	}

	admin := &models.UserAccount{
		ID:               primitive.NewObjectID(),
		Username:         adminUser,
		FullName:         "Admin User",
		AccountType:      "admin",
		RegistrationDate: time.Now().Format(time.RFC3339),
		TelegramID:       "admin_" + adminUser,
		Password:         string(hashedPassword),
	}

	err = userRepo.SaveUser(admin)
	if err != nil {
		return err
	}

	log.Println("Default admin user created")
	return nil
}
-e 
=== ./models/trade.go ===

package models

import (
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type TradeType string

const (
	TradeTypeBuy  TradeType = "BUY"
	TradeTypeSell TradeType = "SELL"
)

type TradeStatus string

const (
	TradeStatusOpen    TradeStatus = "OPEN"
	TradeStatusClosed  TradeStatus = "CLOSED"
	TradeStatusPending TradeStatus = "PENDING"
)

type TradeHistory struct {
	ID         primitive.ObjectID `json:"_id,omitempty" bson:"_id,omitempty"`
	UserID     primitive.ObjectID `json:"user_id" bson:"user_id"`
	SymbolName string             `json:"symbol_name" bson:"symbol_name"`
	TradeType  TradeType          `json:"trade_type" bson:"trade_type"`
	Leverage   int                `json:"leverage" bson:"leverage"`
	Volume     float64            `json:"volume" bson:"volume"`
	EntryPrice float64            `json:"entry_price" bson:"entry_price"`
	ClosePrice float64            `json:"close_price,omitempty" bson:"close_price,omitempty"`
	Status     TradeStatus        `json:"status" bson:"status"`
	ProfitLoss float64            `json:"profit_loss,omitempty" bson:"profit_loss,omitempty"`
	OpenTime   time.Time          `json:"open_time" bson:"open_time"`
	CloseTime  *time.Time         `json:"close_time,omitempty" bson:"close_time,omitempty"`
}
-e 
=== ./models/log.go ===

package models

import (
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type LogEntry struct {
	ID          primitive.ObjectID     `json:"_id,omitempty" bson:"_id,omitempty"`
	UserID      primitive.ObjectID     `json:"user_id,omitempty" bson:"user_id,omitempty"`
	Action      string                 `json:"action" bson:"action"`
	Description string                 `json:"description" bson:"description"`
	IPAddress   string                 `json:"ip_address,omitempty" bson:"ip_address,omitempty"`
	Timestamp   time.Time              `json:"timestamp" bson:"timestamp"`
	Metadata    map[string]interface{} `json:"metadata,omitempty" bson:"metadata,omitempty"`
}
-e 
=== ./models/user.go ===

package models

import "go.mongodb.org/mongo-driver/bson/primitive"

type UserAccount struct {
	ID               primitive.ObjectID `json:"_id,omitempty" bson:"_id,omitempty"`
	Username         string             `json:"username" bson:"username"`
	FullName         string             `json:"full_name" bson:"full_name"`
	PhoneNumber      string             `json:"phone_number" bson:"phone_number"`
	CardNumber       string             `json:"card_number" bson:"card_number"`
	NationalID       string             `json:"national_id" bson:"national_id"`
	Citizenship      string             `json:"citizenship" bson:"citizenship"`
	AccountType      string             `json:"account_type" bson:"account_type"`
	AccountName      string             `json:"account_name" bson:"account_name"`
	Balance          float64            `json:"balance" bson:"balance"`
	Bonus            float64            `json:"bonus" bson:"bonus"`
	Leverage         int                `json:"leverage" bson:"leverage"`
	TradeType        string             `json:"trade_type" bson:"trade_type"`
	RegistrationDate string             `json:"registration_date" bson:"registration_date"`
	WalletAddress    string             `json:"wallet_address" bson:"wallet_address"`
	TelegramID       string             `json:"telegram_id" bson:"telegram_id"`
	Password         string             `json:"password" bson:"password"`
}
-e 
=== ./models/rules.go ===

package models

import (
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type Rule struct {
	ID        primitive.ObjectID `json:"_id,omitempty" bson:"_id,omitempty"`
	Content   string             `json:"content" bson:"content"`
	CreatedAt time.Time          `json:"created_at" bson:"created_at"`
}
-e 
=== ./models/symbol.go ===

package models

import (
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type Symbol struct {
	ID             primitive.ObjectID `json:"_id,omitempty" bson:"_id,omitempty"`
	SymbolName     string             `json:"symbol_name" bson:"symbol_name"`
	DisplayName    string             `json:"display_name" bson:"display_name"`
	Category       string             `json:"category" bson:"category"`
	DeniedAccounts []string           `json:"denied_accounts" bson:"denied_accounts"`
	Leverage       int                `json:"leverage" bson:"leverage"`
	MinLot         float64            `json:"min_lot" bson:"min_lot"`
	MaxLot         float64            `json:"max_lot" bson:"max_lot"`
	Spread         float64            `json:"spread" bson:"spread"`
	Commission     float64            `json:"commission" bson:"commission"`
	TradingHours   TradingHours       `json:"trading_hours" bson:"trading_hours"`
	IsTradingOpen  bool               `json:"is_trading_open" bson:"is_trading_open"`
	CreatedAt      time.Time          `json:"created_at" bson:"created_at"`
	UpdatedAt      time.Time          `json:"updated_at" bson:"updated_at"`
}

type TradingHours struct {
	Unlimited bool      `json:"unlimited" bson:"unlimited"`
	OpenTime  time.Time `json:"open_time,omitempty" bson:"open_time,omitempty"`
	CloseTime time.Time `json:"close_time,omitempty" bson:"close_time,omitempty"`
}
-e 
=== ./models/client.go ===

package models

import (
	"sync"

	"github.com/gorilla/websocket"
)

type Client struct {
	ID      string
	Conn    *websocket.Conn
	Send    chan *PriceData
	Symbols map[string]bool
	mu      sync.RWMutex
}

func NewClient(id string, conn *websocket.Conn) *Client {
	return &Client{
		ID:      id,
		Conn:    conn,
		Send:    make(chan *PriceData, 256),
		Symbols: make(map[string]bool),
	}
}

func (c *Client) Subscribe(symbol string) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.Symbols[symbol] = true
}

func (c *Client) Unsubscribe(symbol string) {
	c.mu.Lock()
	defer c.mu.Unlock()
	delete(c.Symbols, symbol)
}

func (c *Client) IsSubscribed(symbol string) bool {
	c.mu.RLock()
	defer c.mu.RUnlock()
	_, ok := c.Symbols[symbol]
	return ok
}

func (c *Client) Close() {
	c.Conn.Close()
	close(c.Send)
}

type SocketMessage struct {
	Action string `json:"action"`
	Symbol string `json:"symbol"`
}

type SubscriptionResponse struct {
	Status  string   `json:"status"`
	Message string   `json:"message"`
	Symbols []string `json:"symbols,omitempty"`
}

type ErrorResponse struct {
	Error string `json:"error"`
}
-e 
=== ./models/price.go ===

package models

type PriceData struct {
	Symbol    string  `json:"symbol"`
	Ask       float64 `json:"ask"`
	Bid       float64 `json:"bid"`
	Timestamp int64   `json:"timestamp"`
}
-e 
=== ./api/log_handlers.go ===

package api

import (
	"fxtrader/internal/service"
	"net/http"

	"github.com/gin-gonic/gin"
)

type LogHandler struct {
	logService service.LogService
}

func NewLogHandler(logService service.LogService) *LogHandler {
	return &LogHandler{logService: logService}
}

// @Summary Get all logs
// @Description Retrieves a list of all system logs (admin only)
// @Tags Logs
// @Produce json
// @Security BasicAuth
// @Success 200 {array} models.LogEntry
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 500 {object} map[string]string "Failed to retrieve logs"
// @Router /admin/logs [get]
func (h *LogHandler) GetAllLogs(c *gin.Context) {
	logs, err := h.logService.GetAllLogs()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve logs"})
		return
	}
	c.JSON(http.StatusOK, logs)
}

// @Summary Get logs by user ID
// @Description Retrieves logs associated with a specific user ID (admin only)
// @Tags Logs
// @Produce json
// @Security BasicAuth
// @Param user_id path string true "User ID"
// @Success 200 {array} models.LogEntry
// @Failure 400 {object} map[string]string "Invalid user ID"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Router /admin/logs/user/{user_id} [get]
func (h *LogHandler) GetLogsByUser(c *gin.Context) {
	userID := c.Param("user_id")
	logs, err := h.logService.GetLogsByUserID(userID)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
		return
	}
	c.JSON(http.StatusOK, logs)
}
-e 
=== ./api/symbol_handlers.go ===

package api

import (
	"fxtrader/internal/models"
	"fxtrader/internal/service"
	"net/http"

	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

type SymbolHandler struct {
	symbolService service.SymbolService
	logService    service.LogService
}

func NewSymbolHandler(symbolService service.SymbolService, logService service.LogService) *SymbolHandler {
	return &SymbolHandler{symbolService: symbolService, logService: logService}
}

// CreateSymbol creates a new symbol
// @Summary Create a new symbol
// @Description Adds a new trading symbol to the system (admin only)
// @Tags Symbols
// @Accept json
// @Produce json
// @Security BasicAuth
// @Param symbol body models.Symbol true "Symbol data"
// @Success 201 {object} map[string]string "Symbol created"
// @Failure 400 {object} map[string]string "Invalid JSON"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 500 {object} map[string]string "Failed to create symbol"
// @Router /admin/symbols [post]
func (h *SymbolHandler) CreateSymbol(c *gin.Context) {
	var symbol models.Symbol
	if err := c.ShouldBindJSON(&symbol); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	if err := h.symbolService.CreateSymbol(&symbol); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create symbol"})
		return
	}

	metadata := map[string]interface{}{
		"symbol_id":   symbol.ID.Hex(),
		"symbol_name": symbol.SymbolName,
	}
	h.logService.LogAction(primitive.ObjectID{}, "CreateSymbol", "Symbol created", c.ClientIP(), metadata)

	c.JSON(http.StatusCreated, gin.H{"status": "Symbol created", "symbol_id": symbol.ID.Hex()})
}

// @Summary Get symbol by ID
// @Description Retrieves details of a trading symbol by ID
// @Tags Symbols
// @Produce json
// @Param id path string true "Symbol ID"
// @Success 200 {object} models.Symbol
// @Failure 400 {object} map[string]string "Invalid symbol ID"
// @Failure 404 {object} map[string]string "Symbol not found"
// @Router /symbols/{id} [get]
func (h *SymbolHandler) GetSymbol(c *gin.Context) {
	id := c.Param("id")
	symbol, err := h.symbolService.GetSymbol(id)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid symbol ID"})
		return
	}
	if symbol == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Symbol not found"})
		return
	}

	metadata := map[string]interface{}{
		"symbol_id": id,
	}
	h.logService.LogAction(primitive.ObjectID{}, "GetSymbol", "Symbol data retrieved", c.ClientIP(), metadata)

	c.JSON(http.StatusOK, symbol)
}

// GetAllSymbols retrieves all symbols
// @Summary Get all symbols
// @Description Retrieves a list of all trading symbols
// @Tags Symbols
// @Produce json
// @Success 200 {array} models.Symbol
// @Failure 500 {object} map[string]string "Failed to retrieve symbols"
// @Router /symbols [get]
func (h *SymbolHandler) GetAllSymbols(c *gin.Context) {
	symbols, err := h.symbolService.GetAllSymbols()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve symbols"})
		return
	}

	h.logService.LogAction(primitive.ObjectID{}, "GetAllSymbols", "All symbols retrieved", c.ClientIP(), nil)

	c.JSON(http.StatusOK, symbols)
}

// @Summary Update a symbol
// @Description Updates the details of an existing trading symbol (admin only)
// @Tags Symbols
// @Accept json
// @Produce json
// @Security BasicAuth
// @Param id path string true "Symbol ID"
// @Param symbol body models.Symbol true "Updated symbol data"
// @Success 200 {object} map[string]string "Symbol updated"
// @Failure 400 {object} map[string]string "Invalid JSON"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 500 {object} map[string]string "Failed to update symbol"
// @Router /admin/symbols/{id} [put]
func (h *SymbolHandler) UpdateSymbol(c *gin.Context) {
	id := c.Param("id")
	var symbol models.Symbol
	if err := c.ShouldBindJSON(&symbol); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	if err := h.symbolService.UpdateSymbol(id, &symbol); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update symbol"})
		return
	}

	metadata := map[string]interface{}{
		"symbol_id": id,
	}
	h.logService.LogAction(primitive.ObjectID{}, "UpdateSymbol", "Symbol updated", c.ClientIP(), metadata)

	c.JSON(http.StatusOK, gin.H{"status": "Symbol updated"})
}

// @Summary Delete a symbol
// @Description Removes a trading symbol from the system (admin only)
// @Tags Symbols
// @Produce json
// @Security BasicAuth
// @Param id path string true "Symbol ID"
// @Success 200 {object} map[string]string "Symbol deleted"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 500 {object} map[string]string "Failed to delete symbol"
// @Router /admin/symbols/{id} [delete]
func (h *SymbolHandler) DeleteSymbol(c *gin.Context) {
	id := c.Param("id")
	if err := h.symbolService.DeleteSymbol(id); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete symbol"})
		return
	}

	metadata := map[string]interface{}{
		"symbol_id": id,
	}
	h.logService.LogAction(primitive.ObjectID{}, "DeleteSymbol", "Symbol deleted", c.ClientIP(), metadata)

	c.JSON(http.StatusOK, gin.H{"status": "Symbol deleted"})
}
-e 
=== ./api/docs.go ===

package api

// @title FXTrader API
// @version 1.0
// @description API for the FXTrader app
// @host localhost:8080
// @BasePath /api
// @schemes http
// @securityDefinitions.basic BasicAuth
func init() {}
-e 
=== ./api/handlers.go ===

package api

import (
	"fxtrader/internal/models"
	"fxtrader/internal/service"
	"net/http"

	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

type PriceHandler struct {
	priceService service.PriceService
	logService   service.LogService
}

func NewPriceHandler(priceService service.PriceService, logService service.LogService) *PriceHandler {
	return &PriceHandler{priceService: priceService, logService: logService}
}

// @Summary Process new price data
// @Description Receives and processes price data for a trading symbol
// @Tags Prices
// @Accept json
// @Produce json
// @Param priceData body models.PriceData true "Price data"
// @Success 200 {object} map[string]string "Price received"
// @Failure 400 {object} map[string]string "Invalid JSON"
// @Failure 500 {object} map[string]string "Failed to process price"
// @Router /prices [post]
func (h *PriceHandler) HandlePrice(c *gin.Context) {
	var priceData models.PriceData
	if err := c.ShouldBindJSON(&priceData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	if err := h.priceService.ProcessPrice(&priceData); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to process price"})
		return
	}

	metadata := map[string]interface{}{
		"symbol":    priceData.Symbol,
		"ask":       priceData.Ask,
		"bid":       priceData.Bid,
		"timestamp": priceData.Timestamp,
	}
	h.logService.LogAction(primitive.ObjectID{}, "ProcessPrice", "Processed new price data", c.ClientIP(), metadata)

	c.JSON(http.StatusOK, gin.H{"status": "Price received"})
}
-e 
=== ./api/trade_handlers.go ===

package api

import (
	"fxtrader/internal/models"
	"fxtrader/internal/service"
	"net/http"

	"github.com/gin-gonic/gin"
)

type TradeHandler struct {
	tradeService service.TradeService
	logService   service.LogService
}

func NewTradeHandler(tradeService service.TradeService, logService service.LogService) *TradeHandler {
	return &TradeHandler{tradeService: tradeService, logService: logService}
}

// @Summary Place a new trade
// @Description Allows a user to place a trade order
// @Tags Trades
// @Accept json
// @Produce json
// @Security BasicAuth
// @Param trade body TradeRequest true "Trade order data"
// @Success 201 {object} map[string]string "Trade placed"
// @Failure 400 {object} map[string]string "Invalid JSON or parameters"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 500 {object} map[string]string "Failed to place trade"
// @Router /trades [post]
func (h *TradeHandler) PlaceTrade(c *gin.Context) {
	var req TradeRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	userID := c.GetString("user_id") // Set by auth middleware
	trade, err := h.tradeService.PlaceTrade(userID, req.SymbolName, req.TradeType, req.Leverage, req.Volume, req.EntryPrice)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"status": "Trade placed", "trade_id": trade.ID.Hex()})
}

// @Summary Get trade by ID
// @Description Retrieves details of a trade by ID
// @Tags Trades
// @Produce json
// @Security BasicAuth
// @Param id path string true "Trade ID"
// @Success 200 {object} models.TradeHistory
// @Failure 400 {object} map[string]string "Invalid trade ID"
// @Failure 404 {object} map[string]string "Trade not found"
// @Router /trades/{id} [get]
func (h *TradeHandler) GetTrade(c *gin.Context) {
	id := c.Param("id")
	trade, err := h.tradeService.GetTrade(id)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid trade ID"})
		return
	}
	if trade == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Trade not found"})
		return
	}
	c.JSON(http.StatusOK, trade)
}

// @Summary Get user trades
// @Description Retrieves all trades for the authenticated user
// @Tags Trades
// @Produce json
// @Security BasicAuth
// @Success 200 {array} models.TradeHistory
// @Failure 400 {object} map[string]string "Invalid user ID"
// @Failure 500 {object} map[string]string "Failed to retrieve trades"
// @Router /trades [get]
func (h *TradeHandler) GetUserTrades(c *gin.Context) {
	userID := c.GetString("user_id")
	trades, err := h.tradeService.GetTradesByUserID(userID)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
		return
	}
	c.JSON(http.StatusOK, trades)
}

type TradeRequest struct {
	SymbolName string           `json:"symbol_name" binding:"required"`
	TradeType  models.TradeType `json:"trade_type" binding:"required,oneof=BUY SELL"`
	Leverage   int              `json:"leverage" binding:"required,gt=0"`
	Volume     float64          `json:"volume" binding:"required,gt=0"`
	EntryPrice float64          `json:"entry_price" binding:"required,gt=0"`
}
-e 
=== ./api/rules_handlers.go ===

package api

import (
	"fxtrader/internal/models"
	"fxtrader/internal/service"
	"net/http"

	"github.com/gin-gonic/gin"
)

type RuleHandler struct {
	ruleService service.RuleService
}

func NewRuleHandler(ruleService service.RuleService) *RuleHandler {
	return &RuleHandler{ruleService: ruleService}
}

// @Summary Create a new rule
// @Description Adds a new rule to the system (admin only)
// @Tags Rules
// @Accept json
// @Produce json
// @Security BasicAuth
// @Param rule body models.Rule true "Rule data"
// @Success 201 {object} map[string]string "Rule created"
// @Failure 400 {object} map[string]string "Invalid JSON or empty content"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 500 {object} map[string]string "Failed to create rule"
// @Router /admin/rules [post]
func (h *RuleHandler) CreateRule(c *gin.Context) {
	var rule models.Rule
	if err := c.ShouldBindJSON(&rule); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	if rule.Content == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Rule content cannot be empty"})
		return
	}

	if err := h.ruleService.CreateRule(&rule); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create rule"})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"status": "Rule created", "rule_id": rule.ID.Hex()})
}

// @Summary Get rule by ID
// @Description Retrieves details of a rule by ID (admin only)
// @Tags Rules
// @Produce json
// @Security BasicAuth
// @Param id path string true "Rule ID"
// @Success 200 {object} models.Rule
// @Failure 400 {object} map[string]string "Invalid rule ID"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 404 {object} map[string]string "Rule not found"
// @Router /admin/rules/{id} [get]
func (h *RuleHandler) GetRule(c *gin.Context) {
	id := c.Param("id")
	rule, err := h.ruleService.GetRule(id)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid rule ID"})
		return
	}
	if rule == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Rule not found"})
		return
	}
	c.JSON(http.StatusOK, rule)
}

// @Summary Get all rules
// @Description Retrieves a list of all rules (accessible to all users)
// @Tags Rules
// @Produce json
// @Success 200 {array} models.Rule
// @Failure 500 {object} map[string]string "Failed to retrieve rules"
// @Router /rules [get]
func (h *RuleHandler) GetAllRules(c *gin.Context) {
	rules, err := h.ruleService.GetAllRules()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve rules"})
		return
	}
	c.JSON(http.StatusOK, rules)
}

// @Summary Update a rule
// @Description Updates the content of an existing rule (admin only)
// @Tags Rules
// @Accept json
// @Produce json
// @Security BasicAuth
// @Param id path string true "Rule ID"
// @Param rule body models.Rule true "Updated rule data"
// @Success 200 {object} map[string]string "Rule updated"
// @Failure 400 {object} map[string]string "Invalid JSON or empty content"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 500 {object} map[string]string "Failed to update rule"
// @Router /admin/rules/{id} [put]
func (h *RuleHandler) UpdateRule(c *gin.Context) {
	id := c.Param("id")
	var rule models.Rule
	if err := c.ShouldBindJSON(&rule); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	if rule.Content == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Rule content cannot be empty"})
		return
	}

	if err := h.ruleService.UpdateRule(id, &rule); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update rule"})
		return
	}
	c.JSON(http.StatusOK, gin.H{"status": "Rule updated"})
}

// @Summary Delete a rule
// @Description Removes a rule from the system (admin only)
// @Tags Rules
// @Produce json
// @Security BasicAuth
// @Param id path string true "Rule ID"
// @Success 200 {object} map[string]string "Rule deleted"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 500 {object} map[string]string "Failed to delete rule"
// @Router /admin/rules/{id} [delete]
func (h *RuleHandler) DeleteRule(c *gin.Context) {
	id := c.Param("id")
	if err := h.ruleService.DeleteRule(id); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete rule"})
		return
	}
	c.JSON(http.StatusOK, gin.H{"status": "Rule deleted"})
}
-e 
=== ./api/routes.go ===

package api

import (
	"fxtrader/internal/config"
	"fxtrader/internal/middleware"
	"fxtrader/internal/service"
	"fxtrader/internal/ws"
	"os"
	"path/filepath"

	"github.com/gin-gonic/gin"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
)

func SetupRoutes(r *gin.Engine, cfg *config.Config, priceService service.PriceService, userService service.UserService, symbolService service.SymbolService, logService service.LogService, ruleService service.RuleService, tradeService service.TradeService, wsHandler *ws.WebSocketHandler, baseURL string) {
	priceHandler := NewPriceHandler(priceService, logService)
	userHandler := NewUserHandler(userService, logService)
	symbolHandler := NewSymbolHandler(symbolService, logService)
	logHandler := NewLogHandler(logService)
	ruleHandler := NewRuleHandler(ruleService)
	tradeHandler := NewTradeHandler(tradeService, logService)

	wd, err := os.Getwd()
	if err != nil {
		return
	}

	staticPath := filepath.Join(wd, "..", "..", "static")
	r.Static("/static", staticPath)

	r.GET("/chart", func(c *gin.Context) {
		symbolFile := filepath.Join(staticPath, "symbol.html")
		if _, err := os.Stat(symbolFile); os.IsNotExist(err) {
			c.String(404, "symbol.html not found")
			return
		}
		c.File(symbolFile)
	})

	wdRoot := filepath.Join(wd, "..", "..")
	swaggerJSONPath := filepath.Join(wdRoot, "docs", "swagger.json")
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler, ginSwagger.URL("/docs/swagger.json")))
	r.GET("/docs/swagger.json", func(c *gin.Context) {
		c.File(swaggerJSONPath)
	})

	v1 := r.Group("/api")
	{
		v1.POST("/prices", priceHandler.HandlePrice)
		v1.POST("/users/signup", userHandler.SignupUser)
		v1.POST("/users/login", userHandler.Login)
		v1.GET("/users/:id", userHandler.GetUser)
		v1.GET("/symbols", symbolHandler.GetAllSymbols)
		v1.GET("/symbols/:id", symbolHandler.GetSymbol)
		v1.GET("/rules", ruleHandler.GetAllRules)

		user := v1.Group("/").Use(middleware.UserAuthMiddleware(userService))
		{
			user.POST("/trades", tradeHandler.PlaceTrade)
			user.GET("/trades", tradeHandler.GetUserTrades)
			user.GET("/trades/:id", tradeHandler.GetTrade)
		}

		admin := v1.Group("/admin").Use(middleware.AdminAuthMiddleware(cfg))
		{
			admin.POST("/symbols", symbolHandler.CreateSymbol)
			admin.PUT("/symbols/:id", symbolHandler.UpdateSymbol)
			admin.DELETE("/symbols/:id", symbolHandler.DeleteSymbol)
			admin.GET("/logs", logHandler.GetAllLogs)
			admin.GET("/logs/user/:user_id", logHandler.GetLogsByUser)
			admin.POST("/rules", ruleHandler.CreateRule)
			admin.GET("/rules/:id", ruleHandler.GetRule)
			admin.PUT("/rules/:id", ruleHandler.UpdateRule)
			admin.DELETE("/rules/:id", ruleHandler.DeleteRule)
		}
	}

	r.GET("/ws", wsHandler.HandleConnection)
}
-e 
=== ./api/user_handlers.go ===

package api

import (
	"fxtrader/internal/middleware"
	"fxtrader/internal/models"
	"fxtrader/internal/service"
	"net/http"

	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"golang.org/x/crypto/bcrypt"
)

type UserHandler struct {
	userService service.UserService
	logService  service.LogService
}

func NewUserHandler(userService service.UserService, logService service.LogService) *UserHandler {
	return &UserHandler{userService: userService, logService: logService}
}

// @Summary User login
// @Description Authenticates a user and returns a JWT token
// @Tags Users
// @Accept json
// @Produce json
// @Param credentials body LoginRequest true "User credentials"
// @Success 200 {object} map[string]string "Token"
// @Failure 400 {object} map[string]string "Invalid JSON"
// @Failure 401 {object} map[string]string "Invalid credentials"
// @Router /users/login [post]
func (h *UserHandler) Login(c *gin.Context) {
	var req LoginRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	user, err := h.userService.GetUserByTelegramID(req.TelegramID)
	if err != nil || user == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
		return
	}

	if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password)); err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
		return
	}

	token, err := middleware.GenerateJWT(user.ID.Hex())
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate token"})
		return
	}

	metadata := map[string]interface{}{
		"user_id": user.ID.Hex(),
	}
	h.logService.LogAction(user.ID, "UserLogin", "User logged in", c.ClientIP(), metadata)

	c.JSON(http.StatusOK, gin.H{"token": token})
}

func (h *UserHandler) SignupUser(c *gin.Context) {
	var user models.UserAccount
	if err := c.ShouldBindJSON(&user); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to hash password"})
		return
	}
	user.Password = string(hashedPassword)

	if err := h.userService.SignupUser(&user); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create user"})
		return
	}

	metadata := map[string]interface{}{
		"username": user.Username,
		"user_id":  user.ID.Hex(),
	}
	h.logService.LogAction(user.ID, "UserSignup", "User signed up", c.ClientIP(), metadata)

	c.JSON(http.StatusCreated, gin.H{"status": "User created", "user_id": user.ID.Hex()})
}

func (h *UserHandler) GetUser(c *gin.Context) {
	id := c.Param("id")
	user, err := h.userService.GetUser(id)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
		return
	}
	if user == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	metadata := map[string]interface{}{
		"user_id": id,
	}
	h.logService.LogAction(primitive.ObjectID{}, "GetUser", "User data retrieved", c.ClientIP(), metadata)

	c.JSON(http.StatusOK, user)
}

type LoginRequest struct {
	TelegramID string `json:"telegram_id" binding:"required"`
	Password   string `json:"password" binding:"required"`
}
-e 
=== ./service/rule_service.go ===

package service

import (
	"fxtrader/internal/models"
	"fxtrader/internal/repository"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type RuleService interface {
	CreateRule(rule *models.Rule) error
	GetRule(id string) (*models.Rule, error)
	GetAllRules() ([]*models.Rule, error)
	UpdateRule(id string, rule *models.Rule) error
	DeleteRule(id string) error
}

type ruleService struct {
	ruleRepo repository.RuleRepository
}

func NewRuleService(ruleRepo repository.RuleRepository) RuleService {
	return &ruleService{ruleRepo: ruleRepo}
}

func (s *ruleService) CreateRule(rule *models.Rule) error {
	return s.ruleRepo.SaveRule(rule)
}

func (s *ruleService) GetRule(id string) (*models.Rule, error) {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	return s.ruleRepo.GetRuleByID(objID)
}

func (s *ruleService) GetAllRules() ([]*models.Rule, error) {
	return s.ruleRepo.GetAllRules()
}

func (s *ruleService) UpdateRule(id string, rule *models.Rule) error {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return err
	}
	return s.ruleRepo.UpdateRule(objID, rule)
}

func (s *ruleService) DeleteRule(id string) error {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return err
	}
	return s.ruleRepo.DeleteRule(objID)
}
-e 
=== ./service/trade_service.go ===

package service

import (
	"bytes"
	"encoding/json"
	"errors"
	"fxtrader/internal/models"
	"fxtrader/internal/repository"
	"net/http"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type TradeService interface {
	PlaceTrade(userID, symbolName string, tradeType models.TradeType, leverage int, volume, entryPrice float64) (*models.TradeHistory, error)
	GetTrade(id string) (*models.TradeHistory, error)
	GetTradesByUserID(userID string) ([]*models.TradeHistory, error)
}

type tradeService struct {
	tradeRepo   repository.TradeRepository
	symbolRepo  repository.SymbolRepository
	logService  LogService
	mt5Endpoint string // URL for MT5 trade API
}

func NewTradeService(tradeRepo repository.TradeRepository, symbolRepo repository.SymbolRepository, logService LogService, mt5Endpoint string) TradeService {
	return &tradeService{
		tradeRepo:   tradeRepo,
		symbolRepo:  symbolRepo,
		logService:  logService,
		mt5Endpoint: mt5Endpoint, // e.g., "http://mt5-server:8080/trade"
	}
}

func (s *tradeService) PlaceTrade(userID, symbolName string, tradeType models.TradeType, leverage int, volume, entryPrice float64) (*models.TradeHistory, error) {
	// Validate user ID
	userObjID, err := primitive.ObjectIDFromHex(userID)
	if err != nil {
		return nil, errors.New("invalid user ID")
	}

	// Check if symbol exists
	symbols, err := s.symbolRepo.GetAllSymbols()
	if err != nil {
		return nil, errors.New("failed to fetch symbols")
	}
	var symbol *models.Symbol
	for _, s := range symbols {
		if s.SymbolName == symbolName {
			symbol = s
			break
		}
	}
	if symbol == nil {
		return nil, errors.New("symbol not found")
	}

	// Validate trade parameters
	if tradeType != models.TradeTypeBuy && tradeType != models.TradeTypeSell {
		return nil, errors.New("invalid trade type")
	}
	if volume < symbol.MinLot || volume > symbol.MaxLot {
		return nil, errors.New("volume out of allowed range")
	}
	if leverage > symbol.Leverage {
		return nil, errors.New("leverage exceeds symbol limit")
	}

	// Create trade record
	trade := &models.TradeHistory{
		UserID:     userObjID,
		SymbolName: symbolName,
		TradeType:  tradeType,
		Leverage:   leverage,
		Volume:     volume,
		EntryPrice: entryPrice,
		Status:     "PENDING",
	}

	// Send trade to MT5
	err = s.sendTradeToMT5(trade)
	if err != nil {
		return nil, err
	}

	// Save trade to database
	err = s.tradeRepo.SaveTrade(trade)
	if err != nil {
		return nil, err
	}

	// Log the action
	metadata := map[string]interface{}{
		"trade_id":    trade.ID.Hex(),
		"symbol_name": symbolName,
		"trade_type":  tradeType,
		"leverage":    leverage,
		"volume":      volume,
		"entry_price": entryPrice,
	}
	s.logService.LogAction(userObjID, "PlaceTrade", "Trade order placed", "", metadata)

	return trade, nil
}

func (s *tradeService) sendTradeToMT5(trade *models.TradeHistory) error {
	// Prepare trade request for MT5
	tradeRequest := map[string]interface{}{
		"trade_id":    trade.ID.Hex(),
		"user_id":     trade.UserID.Hex(),
		"symbol":      trade.SymbolName,
		"trade_type":  trade.TradeType,
		"leverage":    trade.Leverage,
		"volume":      trade.Volume,
		"entry_price": trade.EntryPrice,
		"timestamp":   trade.OpenTime.Unix(),
	}

	data, err := json.Marshal(tradeRequest)
	if err != nil {
		return err
	}

	// Send to MT5 (replace with actual MT5 API endpoint)
	resp, err := http.Post(s.mt5Endpoint, "application/json", bytes.NewBuffer(data))
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return errors.New("failed to send trade to MT5")
	}

	// Update trade status based on MT5 response (simplified)
	trade.Status = "OPEN"
	return nil
}

func (s *tradeService) GetTrade(id string) (*models.TradeHistory, error) {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	return s.tradeRepo.GetTradeByID(objID)
}

func (s *tradeService) GetTradesByUserID(userID string) ([]*models.TradeHistory, error) {
	objID, err := primitive.ObjectIDFromHex(userID)
	if err != nil {
		return nil, err
	}
	return s.tradeRepo.GetTradesByUserID(objID)
}
-e 
=== ./service/price_service.go ===

package service

import (
	"fxtrader/internal/models"
	"fxtrader/internal/repository"
	"fxtrader/internal/ws"
	"log"
)

type PriceService interface {
	ProcessPrice(data *models.PriceData) error
}

type priceService struct {
	repo repository.PriceRepository
	hub  *ws.Hub
}

func NewPriceService(repo repository.PriceRepository, hub *ws.Hub) PriceService {
	return &priceService{
		repo: repo,
		hub:  hub,
	}
}

func (s *priceService) ProcessPrice(data *models.PriceData) error {
	if err := s.repo.SavePrice(data); err != nil {
		return err
	}

	s.hub.BroadcastPrice(data)
	log.Printf("Price broadcast: %s Ask: %.5f Bid: %.5f", data.Symbol, data.Ask, data.Bid)

	return nil
}
-e 
=== ./service/user_service.go ===

package service

import (
	"fxtrader/internal/models"
	"fxtrader/internal/repository"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type UserService interface {
	SignupUser(user *models.UserAccount) error
	GetUser(id string) (*models.UserAccount, error)
	GetUserByTelegramID(telegramID string) (*models.UserAccount, error)
}

type userService struct {
	userRepo repository.UserRepository
}

func NewUserService(userRepo repository.UserRepository) UserService {
	return &userService{userRepo: userRepo}
}

func (s *userService) SignupUser(user *models.UserAccount) error {
	user.ID = primitive.NewObjectID()
	user.RegistrationDate = time.Now().Format(time.RFC3339)
	return s.userRepo.SaveUser(user)
}

func (s *userService) GetUser(id string) (*models.UserAccount, error) {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	return s.userRepo.GetUserByID(objID)
}

func (s *userService) GetUserByTelegramID(telegramID string) (*models.UserAccount, error) {
	return s.userRepo.GetUserByTelegramID(telegramID)
}
-e 
=== ./service/log_service.go ===

package service

import (
	"fxtrader/internal/models"
	"fxtrader/internal/repository"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type LogService interface {
	LogAction(userID primitive.ObjectID, action, description, ipAddress string, metadata map[string]interface{}) error
	GetAllLogs() ([]*models.LogEntry, error)
	GetLogsByUserID(userID string) ([]*models.LogEntry, error)
}

type logService struct {
	logRepo repository.LogRepository
}

func NewLogService(logRepo repository.LogRepository) LogService {
	return &logService{logRepo: logRepo}
}

func (s *logService) LogAction(userID primitive.ObjectID, action, description, ipAddress string, metadata map[string]interface{}) error {
	logEntry := &models.LogEntry{
		UserID:      userID,
		Action:      action,
		Description: description,
		IPAddress:   ipAddress,
		Metadata:    metadata,
	}
	return s.logRepo.SaveLog(logEntry)
}

func (s *logService) GetAllLogs() ([]*models.LogEntry, error) {
	return s.logRepo.GetAllLogs()
}

func (s *logService) GetLogsByUserID(userID string) ([]*models.LogEntry, error) {
	objID, err := primitive.ObjectIDFromHex(userID)
	if err != nil {
		return nil, err
	}
	return s.logRepo.GetLogsByUserID(objID)
}
-e 
=== ./service/symbo_service.go ===

package service

import (
	"fxtrader/internal/models"
	"fxtrader/internal/repository"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type SymbolService interface {
	CreateSymbol(symbol *models.Symbol) error
	GetSymbol(id string) (*models.Symbol, error)
	GetAllSymbols() ([]*models.Symbol, error)
	UpdateSymbol(id string, symbol *models.Symbol) error
	DeleteSymbol(id string) error
}

type symbolService struct {
	symbolRepo repository.SymbolRepository
}

func NewSymbolService(symbolRepo repository.SymbolRepository) SymbolService {
	return &symbolService{symbolRepo: symbolRepo}
}

func (s *symbolService) CreateSymbol(symbol *models.Symbol) error {
	return s.symbolRepo.SaveSymbol(symbol)
}

func (s *symbolService) GetSymbol(id string) (*models.Symbol, error) {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	return s.symbolRepo.GetSymbolByID(objID)
}

func (s *symbolService) GetAllSymbols() ([]*models.Symbol, error) {
	return s.symbolRepo.GetAllSymbols()
}

func (s *symbolService) UpdateSymbol(id string, symbol *models.Symbol) error {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return err
	}
	return s.symbolRepo.UpdateSymbol(objID, symbol)
}

func (s *symbolService) DeleteSymbol(id string) error {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return err
	}
	return s.symbolRepo.DeleteSymbol(objID)
}
