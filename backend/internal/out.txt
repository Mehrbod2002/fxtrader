-e 
=== ./api/copy_trade_handlers.go ===

package api

import (
	"net/http"

	"github.com/mehrbod2002/fxtrader/internal/service"

	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

type CopyTradeHandler struct {
	copyTradeService service.CopyTradeService
	logService       service.LogService
}

func NewCopyTradeHandler(copyTradeService service.CopyTradeService, logService service.LogService) *CopyTradeHandler {
	return &CopyTradeHandler{copyTradeService: copyTradeService, logService: logService}
}

// @Summary Create a copy trade subscription
// @Description Allows a user to follow a trader and allocate funds for copy trading
// @Tags CopyTrading
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param subscription body CopyTradeRequest true "Subscription data"
// @Success 201 {object} map[string]string "Subscription created"
// @Failure 400 {object} map[string]string "Invalid JSON or parameters"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 500 {object} map[string]string "Failed to create subscription"
// @Router /copy-trades [post]
func (h *CopyTradeHandler) CreateSubscription(c *gin.Context) {
	var req CopyTradeRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	followerID := c.GetString("user_id")
	subscription, err := h.copyTradeService.CreateSubscription(followerID, req.LeaderID, req.AllocatedAmount)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	metadata := map[string]interface{}{
		"subscription_id": subscription.ID.Hex(),
		"follower_id":     followerID,
		"leader_id":       req.LeaderID,
	}
	h.logService.LogAction(primitive.ObjectID{}, "CreateCopySubscription", "Copy trade subscription created", c.ClientIP(), metadata)

	c.JSON(http.StatusCreated, gin.H{"status": "Subscription created", "subscription_id": subscription.ID.Hex()})
}

// @Summary Get user copy trade subscriptions
// @Description Retrieves all copy trade subscriptions for the authenticated user
// @Tags CopyTrading
// @Produce json
// @Security BearerAuth
// @Success 200 {array} models.CopyTradeSubscription
// @Failure 400 {object} map[string]string "Invalid user ID"
// @Failure 500 {object} map[string]string "Failed to retrieve subscriptions"
// @Router /copy-trades [get]
func (h *CopyTradeHandler) GetUserSubscriptions(c *gin.Context) {
	followerID := c.GetString("user_id")
	subscriptions, err := h.copyTradeService.GetSubscriptionsByFollowerID(followerID)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	metadata := map[string]interface{}{
		"follower_id": followerID,
		"count":       len(subscriptions),
	}
	h.logService.LogAction(primitive.ObjectID{}, "GetCopySubscriptions", "User copy subscriptions retrieved", c.ClientIP(), metadata)

	c.JSON(http.StatusOK, subscriptions)
}

// @Summary Get copy trade subscription by ID
// @Description Retrieves details of a specific copy trade subscription
// @Tags CopyTrading
// @Produce json
// @Security BearerAuth
// @Param id path string true "Subscription ID"
// @Success 200 {object} models.CopyTradeSubscription
// @Failure 400 {object} map[string]string "Invalid subscription ID"
// @Failure 404 {object} map[string]string "Subscription not found"
// @Router /copy-trades/{id} [get]
func (h *CopyTradeHandler) GetSubscription(c *gin.Context) {
	subscriptionID := c.Param("id")
	subscription, err := h.copyTradeService.GetSubscription(subscriptionID)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid subscription ID"})
		return
	}
	if subscription == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Subscription not found"})
		return
	}

	metadata := map[string]interface{}{
		"subscription_id": subscriptionID,
	}
	h.logService.LogAction(primitive.ObjectID{}, "GetCopySubscription", "Copy subscription data retrieved", c.ClientIP(), metadata)

	c.JSON(http.StatusOK, subscription)
}

type CopyTradeRequest struct {
	LeaderID        string  `json:"leader_id" binding:"required"`
	AllocatedAmount float64 `json:"allocated_amount" binding:"required,gt=0"`
}
-e 
=== ./api/trade_handlers.go ===

package api

import (
	"net/http"
	"strings"
	"time"

	"github.com/mehrbod2002/fxtrader/internal/service"

	"github.com/mehrbod2002/fxtrader/internal/models"

	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

type TradeHandler struct {
	tradeService service.TradeService
	logService   service.LogService
}

func NewTradeHandler(tradeService service.TradeService, logService service.LogService) *TradeHandler {
	return &TradeHandler{tradeService: tradeService, logService: logService}
}

// @Summary Place a new trade
// @Description Allows an authenticated user to place a trade order
// @Tags Trades
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param trade body TradeRequest true "Trade order data"
// @Success 201 {object} map[string]string "Trade placed"
// @Failure 400 {object} map[string]string "Invalid JSON or parameters"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 500 {object} map[string]string "Server error"
// @Router /api/trades [post]
func (h *TradeHandler) PlaceTrade(c *gin.Context) {
	var req TradeRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	if req.OrderType == "MARKET" && req.EntryPrice > 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "EntryPrice not allowed for MARKET orders"})
		return
	}
	if strings.Contains(req.OrderType, "LIMIT") || strings.Contains(req.OrderType, "STOP") {
		if req.EntryPrice <= 0 {
			c.JSON(http.StatusBadRequest, gin.H{"error": "EntryPrice required for LIMIT/STOP orders"})
			return
		}
	}

	userID := c.GetString("user_id")
	trade, err := h.tradeService.PlaceTrade(userID, req.SymbolName, req.TradeType, req.OrderType, req.Leverage, req.Volume, req.EntryPrice, req.StopLoss, req.TakeProfit, req.Expiration)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	metadata := map[string]interface{}{
		"user_id":    userID,
		"trade_id":   trade.ID.Hex(),
		"symbol":     req.SymbolName,
		"trade_type": req.TradeType,
		"order_type": req.OrderType,
	}
	h.logService.LogAction(trade.UserID, "PlaceTrade", "Trade order placed", c.ClientIP(), metadata)

	c.JSON(http.StatusCreated, gin.H{"status": "Trade placed", "trade_id": trade.ID.Hex()})
}

// @Summary Get user trades
// @Description Retrieves a list of trades for the authenticated user
// @Tags Trades
// @Produce json
// @Security BearerAuth
// @Success 200 {array} models.TradeHistory
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 500 {object} map[string]string "Server error"
// @Router /api/trades [get]
func (h *TradeHandler) GetUserTrades(c *gin.Context) {
	userID := c.GetString("user_id")
	trades, err := h.tradeService.GetTradesByUserID(userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve trades"})
		return
	}

	userObjID, _ := primitive.ObjectIDFromHex(userID)
	metadata := map[string]interface{}{
		"user_id": userID,
		"count":   len(trades),
	}
	h.logService.LogAction(userObjID, "GetUserTrades", "Retrieved user trades", c.ClientIP(), metadata)

	c.JSON(http.StatusOK, trades)
}

// @Summary Get trade by ID
// @Description Retrieves details of a specific trade by its ID (user or admin)
// @Tags Trades
// @Produce json
// @Security BearerAuth
// @Param id path string true "Trade ID"
// @Success 200 {object} models.TradeHistory
// @Failure 400 {object} map[string]string "Invalid trade ID"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 403 {object} map[string]string "Forbidden (trade belongs to another user)"
// @Failure 404 {object} map[string]string "Trade not found"
// @Router /api/trades/{id} [get]
func (h *TradeHandler) GetTrade(c *gin.Context) {
	tradeID := c.Param("id")
	userID := c.GetString("user_id")

	trade, err := h.tradeService.GetTrade(tradeID)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid trade ID"})
		return
	}
	if trade == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Trade not found"})
		return
	}

	// Admin
	// if trade.UserID.Hex() != userID {
	// 	c.JSON(http.StatusForbidden, gin.H{"error": "Forbidden (trade belongs to another user)"})
	// 	return
	// }

	userObjID, _ := primitive.ObjectIDFromHex(userID)
	metadata := map[string]interface{}{
		"user_id":  userID,
		"trade_id": tradeID,
	}
	h.logService.LogAction(userObjID, "GetTrade", "Trade data retrieved", c.ClientIP(), metadata)

	c.JSON(http.StatusOK, trade)
}

// @Summary Handle trade response from MT5
// @Description Processes trade response from MT5 EA
// @Tags Trades
// @Accept json
// @Produce json
// @Param response body service.TradeResponse true "Trade response data"
// @Success 200 {object} map[string]string "Response processed"
// @Failure 400 {object} map[string]string "Invalid JSON or parameters"
// @Failure 500 {object} map[string]string "Server error"
// @Router /api/trade-response [post]
func (h *TradeHandler) HandleTradeResponse(c *gin.Context) {
	var response service.TradeResponse
	if err := c.ShouldBindJSON(&response); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	if err := h.tradeService.HandleTradeResponse(response); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"status": "Response processed"})
}

// @Summary Get all trades
// @Description Retrieves a list of all trades (admin only)
// @Tags Trades
// @Produce json
// @Security BearerAuth
// @Success 200 {array} models.TradeHistory
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 403 {object} map[string]string "Forbidden (non-admin)"
// @Failure 500 {object} map[string]string "Server error"
// @Router /api/v1/admin/trades [get]
func (h *TradeHandler) GetAllTrades(c *gin.Context) {
	trades, err := h.tradeService.GetAllTrades()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve trades"})
		return
	}

	userID := c.GetString("user_id")
	userObjID, _ := primitive.ObjectIDFromHex(userID)
	metadata := map[string]interface{}{
		"admin_id": userID,
		"count":    len(trades),
	}
	h.logService.LogAction(userObjID, "GetAllTrades", "Retrieved all trades", c.ClientIP(), metadata)

	c.JSON(http.StatusOK, trades)
}

type TradeRequest struct {
	SymbolName string           `json:"symbol_name" binding:"required"`
	TradeType  models.TradeType `json:"trade_type" binding:"required,oneof=BUY SELL"`
	OrderType  string           `json:"order_type" binding:"required,oneof=MARKET LIMIT BUY_STOP SELL_STOP BUY_LIMIT SELL_LIMIT"`
	Leverage   int              `json:"leverage" binding:"required,gt=0"`
	Volume     float64          `json:"volume" binding:"required,gt=0"`
	EntryPrice float64          `json:"entry_price" binding:"omitempty,gt=0"`
	StopLoss   float64          `json:"stop_loss" binding:"omitempty,gte=0"`
	TakeProfit float64          `json:"take_profit" binding:"omitempty,gte=0"`
	Expiration *time.Time       `json:"expiration" binding:"omitempty"`
}
-e 
=== ./models/trade.go ===

package models

import (
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type TradeHistory struct {
	ID             primitive.ObjectID `bson:"_id"`
	UserID         primitive.ObjectID `bson:"user_id"`
	Symbol         string             `bson:"symbol"`
	TradeType      TradeType          `bson:"trade_type"`
	OrderType      string             `bson:"order_type"`
	Leverage       int                `bson:"leverage"`
	Volume         float64            `bson:"volume"`
	EntryPrice     float64            `bson:"entry_price"`
	StopLoss       float64            `bson:"stop_loss"`
	TakeProfit     float64            `bson:"take_profit"`
	OpenTime       time.Time          `bson:"open_time"`
	CloseTime      *time.Time         `bson:"close_time,omitempty"`
	Status         string             `bson:"status"`
	MatchedTradeID string             `bson:"matched_trade_id,omitempty"`
	Expiration     *time.Time         `bson:"expiration,omitempty"`
}

type TradeType string

const (
	TradeTypeBuy  TradeType = "BUY"
	TradeTypeSell TradeType = "SELL"
)

type TradeStatus string

const (
	TradeStatusPending TradeStatus = "PENDING"
	TradeStatusOpen    TradeStatus = "OPEN"
	TradeStatusClosed  TradeStatus = "CLOSED"
)
-e 
=== ./models/copy_trade.go ===

package models

import (
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type ActivceStatus string

const (
	Active   ActivceStatus = "active"
	Inactive ActivceStatus = "inactive"
)

type CopyTradeSubscription struct {
	ID              primitive.ObjectID `json:"_id,omitempty" bson:"_id,omitempty"`
	FollowerID      string             `json:"follower_id" bson:"follower_id"`
	LeaderID        string             `json:"leader_id" bson:"leader_id"`
	AllocatedAmount float64            `json:"allocated_amount" bson:"allocated_amount"`
	Status          ActivceStatus      `json:"status" bson:"status"`
	CreatedAt       time.Time          `json:"created_at" bson:"created_at"`
}

type CopyTrade struct {
	ID              primitive.ObjectID `json:"_id,omitempty" bson:"_id,omitempty"`
	SubscriptionID  primitive.ObjectID `json:"subscription_id" bson:"subscription_id"`
	LeaderTradeID   primitive.ObjectID `json:"leader_trade_id" bson:"leader_trade_id"`
	FollowerTradeID primitive.ObjectID `json:"follower_trade_id" bson:"follower_trade_id"`
	CreatedAt       time.Time          `json:"created_at" bson:"created_at"`
}
-e 
=== ./service/copy_trade_service.go ===

package service

import (
	"errors"
	"math"

	"github.com/mehrbod2002/fxtrader/internal/models"
	"github.com/mehrbod2002/fxtrader/internal/repository"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type CopyTradeService interface {
	CreateSubscription(followerID, leaderID string, allocatedAmount float64) (*models.CopyTradeSubscription, error)
	GetSubscription(id string) (*models.CopyTradeSubscription, error)
	GetSubscriptionsByFollowerID(followerID string) ([]*models.CopyTradeSubscription, error)
	MirrorTrade(leaderTrade *models.TradeHistory) error
	SetTradeService(tradeService TradeService)
}

type copyTradeService struct {
	copyTradeRepo repository.CopyTradeRepository
	tradeService  TradeService
	userService   UserService
	logService    LogService
}

func (s *copyTradeService) SetTradeService(tradeService TradeService) {
	s.tradeService = tradeService
}

func NewCopyTradeService(copyTradeRepo repository.CopyTradeRepository, tradeService TradeService, userService UserService, logService LogService) CopyTradeService {
	return &copyTradeService{
		copyTradeRepo: copyTradeRepo,
		tradeService:  tradeService,
		userService:   userService,
		logService:    logService,
	}
}

func (s *copyTradeService) CreateSubscription(followerID, leaderID string, allocatedAmount float64) (*models.CopyTradeSubscription, error) {
	if followerID == leaderID {
		return nil, errors.New("cannot follow yourself")
	}
	if allocatedAmount <= 0 {
		return nil, errors.New("allocated amount must be positive")
	}

	follower, err := s.userService.GetUser(followerID)
	if err != nil || follower == nil {
		return nil, errors.New("follower not found")
	}
	leader, err := s.userService.GetUser(leaderID)
	if err != nil || leader == nil {
		return nil, errors.New("leader not found")
	}

	followerBalance, err := s.tradeService.RequestBalance(followerID)
	if err != nil {
		return nil, errors.New("failed to fetch follower balance")
	}
	if followerBalance < allocatedAmount {
		return nil, errors.New("insufficient balance")
	}

	subscription := &models.CopyTradeSubscription{
		FollowerID:      followerID,
		LeaderID:        leaderID,
		AllocatedAmount: allocatedAmount,
		Status:          "ACTIVE",
	}

	err = s.copyTradeRepo.SaveSubscription(subscription)
	if err != nil {
		return nil, err
	}

	metadata := map[string]interface{}{
		"subscription_id":  subscription.ID.Hex(),
		"follower_id":      followerID,
		"leader_id":        leaderID,
		"allocated_amount": allocatedAmount,
	}
	s.logService.LogAction(primitive.ObjectID{}, "CreateCopySubscription", "Copy trade subscription created", "", metadata)

	return subscription, nil
}

func (s *copyTradeService) GetSubscription(id string) (*models.CopyTradeSubscription, error) {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, errors.New("invalid subscription ID")
	}
	return s.copyTradeRepo.GetSubscriptionByID(objID)
}

func (s *copyTradeService) GetSubscriptionsByFollowerID(followerID string) ([]*models.CopyTradeSubscription, error) {
	return s.copyTradeRepo.GetSubscriptionsByFollowerID(followerID)
}

func (s *copyTradeService) MirrorTrade(leaderTrade *models.TradeHistory) error {
	subscriptions, err := s.copyTradeRepo.GetActiveSubscriptionsByLeaderID(leaderTrade.UserID.Hex())
	if err != nil {
		return err
	}

	leaderBalance, err := s.tradeService.RequestBalance(leaderTrade.UserID.Hex())
	if err != nil {
		return errors.New("failed to fetch leader balance")
	}
	if leaderBalance <= 0 {
		return errors.New("leader balance is zero")
	}

	volumeRatio := leaderTrade.Volume / leaderBalance

	for _, sub := range subscriptions {
		followerBalance, err := s.tradeService.RequestBalance(sub.FollowerID)
		if err != nil {
			continue
		}

		followerVolume := math.Min(sub.AllocatedAmount, followerBalance) * volumeRatio
		followerTrade, err := s.tradeService.PlaceTrade(
			sub.FollowerID,
			leaderTrade.Symbol,
			leaderTrade.TradeType,
			leaderTrade.OrderType,
			leaderTrade.Leverage,
			followerVolume,
			leaderTrade.EntryPrice,
			leaderTrade.StopLoss,
			leaderTrade.TakeProfit,
			leaderTrade.Expiration,
		)
		if err != nil {
			continue
		}

		copyTrade := &models.CopyTrade{
			SubscriptionID:  sub.ID,
			LeaderTradeID:   leaderTrade.ID,
			FollowerTradeID: followerTrade.ID,
		}
		err = s.copyTradeRepo.SaveCopyTrade(copyTrade)
		if err != nil {
			continue
		}

		metadata := map[string]interface{}{
			"copy_trade_id":     copyTrade.ID.Hex(),
			"subscription_id":   sub.ID.Hex(),
			"leader_trade_id":   leaderTrade.ID.Hex(),
			"follower_trade_id": followerTrade.ID.Hex(),
			"follower_volume":   followerVolume,
		}
		s.logService.LogAction(primitive.ObjectID{}, "MirrorTrade", "Trade mirrored for follower", "", metadata)
	}

	return nil
}
-e 
=== ./service/trade_service.go ===

package service

import (
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"net"
	"time"

	"github.com/mehrbod2002/fxtrader/internal/models"
	"github.com/mehrbod2002/fxtrader/internal/repository"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type TradeService interface {
	PlaceTrade(userID, symbol string, tradeType models.TradeType, orderType string, leverage int, volume, entryPrice, stopLoss, takeProfit float64, expiration *time.Time) (*models.TradeHistory, error)
	GetTrade(id string) (*models.TradeHistory, error)
	GetTradesByUserID(userID string) ([]*models.TradeHistory, error)
	GetAllTrades() ([]*models.TradeHistory, error)
	HandleTradeResponse(response TradeResponse) error
	StartTCPListener() error
	RequestBalance(userID string) (float64, error)
}

type tradeService struct {
	tradeRepo        repository.TradeRepository
	symbolRepo       repository.SymbolRepository
	logService       LogService
	tcpConn          *net.TCPConn
	mt5TCPAddr       *net.TCPAddr
	listenTCPAddr    *net.TCPAddr
	responseChan     chan TradeResponse
	balanceChan      chan BalanceResponse
	copyTradeService CopyTradeService
}

type BalanceResponse struct {
	Type      string  `json:"type"`
	UserID    string  `json:"user_id"`
	Balance   float64 `json:"balance"`
	Error     string  `json:"error,omitempty"`
	Timestamp int64   `json:"timestamp"`
}

func NewTradeService(tradeRepo repository.TradeRepository, symbolRepo repository.SymbolRepository, logService LogService, copyTradeService CopyTradeService, mt5Host string, mt5Port, listenPort int) (TradeService, error) {
	mt5Addr, err := net.ResolveTCPAddr("tcp", fmt.Sprintf("%s:%d", mt5Host, mt5Port))
	if err != nil {
		return nil, err
	}
	listenAddr, err := net.ResolveTCPAddr("tcp", fmt.Sprintf(":%d", listenPort))
	if err != nil {
		return nil, err
	}

	fmt.Println(mt5Addr)
	conn, err := net.DialTCP("tcp", nil, mt5Addr)
	if err != nil {
		fmt.Println(err)
		return nil, errors.New("failed to connect to MT5 TCP server")
	}

	return &tradeService{
		tradeRepo:        tradeRepo,
		symbolRepo:       symbolRepo,
		logService:       logService,
		tcpConn:          conn,
		mt5TCPAddr:       mt5Addr,
		listenTCPAddr:    listenAddr,
		responseChan:     make(chan TradeResponse, 100),
		balanceChan:      make(chan BalanceResponse, 100),
		copyTradeService: copyTradeService,
	}, nil
}

func (s *tradeService) StartTCPListener() error {
	listener, err := net.ListenTCP("tcp", s.listenTCPAddr)
	if err != nil {
		return err
	}

	go func() {
		defer listener.Close()
		for {
			conn, err := listener.AcceptTCP()
			if err != nil {
				log.Printf("Failed to accept TCP connection: %v", err)
				continue
			}
			go s.handleTCPConnection(conn)
		}
	}()

	go func() {
		for response := range s.responseChan {
			if err := s.HandleTradeResponse(response); err != nil {
				log.Printf("Failed to handle trade response: %v", err)
			}
		}
	}()

	go func() {
		for response := range s.balanceChan {
			if err := s.handleBalanceResponse(response); err != nil {
				log.Printf("Failed to handle balance response: %v", err)
			}
		}
	}()

	return nil
}

func (s *tradeService) handleTCPConnection(conn *net.TCPConn) {
	defer conn.Close()
	buf := make([]byte, 4096)
	for {
		n, err := conn.Read(buf)
		if err != nil {
			log.Printf("Failed to read from TCP connection: %v", err)
			return
		}

		var msg map[string]interface{}
		if err := json.Unmarshal(buf[:n], &msg); err != nil {
			log.Printf("Failed to unmarshal TCP message: %v", err)
			continue
		}

		if msgType, ok := msg["type"].(string); ok {
			if msgType == "trade_response" {
				var response TradeResponse
				if err := json.Unmarshal(buf[:n], &response); err != nil {
					log.Printf("Failed to unmarshal trade response: %v", err)
					continue
				}
				s.responseChan <- response
			} else if msgType == "balance_response" {
				var response BalanceResponse
				if err := json.Unmarshal(buf[:n], &response); err != nil {
					log.Printf("Failed to unmarshal balance response: %v", err)
					continue
				}
				s.balanceChan <- response
			}
		}
	}
}

func (s *tradeService) PlaceTrade(userID, symbolName string, tradeType models.TradeType, orderType string, leverage int, volume, entryPrice, stopLoss, takeProfit float64, expiration *time.Time) (*models.TradeHistory, error) {
	userObjID, err := primitive.ObjectIDFromHex(userID)
	if err != nil {
		return nil, errors.New("invalid user ID")
	}

	symbols, err := s.symbolRepo.GetAllSymbols()
	if err != nil {
		return nil, errors.New("failed to fetch symbols")
	}
	var symbol *models.Symbol
	for _, sym := range symbols {
		if sym.SymbolName == symbolName {
			symbol = sym
			break
		}
	}
	if symbol == nil {
		return nil, errors.New("symbol not found")
	}

	if tradeType != models.TradeTypeBuy && tradeType != models.TradeTypeSell {
		return nil, errors.New("invalid trade type")
	}

	validOrderTypes := []string{"MARKET", "LIMIT", "BUY_STOP", "SELL_STOP", "BUY_LIMIT", "SELL_LIMIT"}
	isValidOrderType := false
	for _, ot := range validOrderTypes {
		if orderType == ot {
			isValidOrderType = true
			break
		}
	}
	if !isValidOrderType {
		return nil, errors.New("invalid order type")
	}

	if volume < symbol.MinLot || volume > symbol.MaxLot {
		return nil, errors.New("volume out of allowed range")
	}

	if leverage > symbol.Leverage {
		return nil, errors.New("leverage exceeds symbol limit")
	}

	if orderType != "MARKET" && entryPrice <= 0 {
		return nil, errors.New("entry price required for non-market orders")
	}
	if orderType == "MARKET" && entryPrice > 0 {
		return nil, errors.New("entry price not allowed for market orders")
	}

	if stopLoss < 0 || takeProfit < 0 {
		return nil, errors.New("stop loss and take profit cannot be negative")
	}

	if expiration != nil && expiration.Before(time.Now()) {
		return nil, errors.New("expiration time must be in the future")
	}

	trade := &models.TradeHistory{
		ID:         primitive.NewObjectID(),
		UserID:     userObjID,
		Symbol:     symbolName,
		TradeType:  tradeType,
		OrderType:  orderType,
		Leverage:   leverage,
		Volume:     volume,
		EntryPrice: entryPrice,
		StopLoss:   stopLoss,
		TakeProfit: takeProfit,
		OpenTime:   time.Now(),
		Status:     string(models.TradeStatusPending),
		Expiration: expiration,
	}

	err = s.sendTradeToMT5(trade)
	if err != nil {
		return nil, err
	}

	err = s.tradeRepo.SaveTrade(trade)
	if err != nil {
		return nil, err
	}

	metadata := map[string]interface{}{
		"trade_id":    trade.ID.Hex(),
		"symbol_name": symbolName,
		"trade_type":  tradeType,
		"order_type":  orderType,
		"leverage":    leverage,
		"volume":      volume,
		"entry_price": entryPrice,
		"stop_loss":   stopLoss,
		"take_profit": takeProfit,
		"expiration":  expiration,
	}
	s.logService.LogAction(userObjID, "PlaceTrade", "Trade order placed", "", metadata)

	go func() {
		if err := s.copyTradeService.MirrorTrade(trade); err != nil {
			log.Printf("Failed to mirror trade: %v", err)
		}
	}()

	return trade, nil
}

func (s *tradeService) sendTradeToMT5(trade *models.TradeHistory) error {
	tradeRequest := map[string]interface{}{
		"trade_id":    trade.ID.Hex(),
		"user_id":     trade.UserID.Hex(),
		"symbol":      trade.Symbol,
		"trade_type":  trade.TradeType,
		"order_type":  trade.OrderType,
		"leverage":    trade.Leverage,
		"volume":      trade.Volume,
		"entry_price": trade.EntryPrice,
		"stop_loss":   trade.StopLoss,
		"take_profit": trade.TakeProfit,
		"timestamp":   trade.OpenTime.Unix(),
		"expiration":  0,
	}
	if trade.Expiration != nil {
		tradeRequest["expiration"] = trade.Expiration.Unix()
	}

	data, err := json.Marshal(tradeRequest)
	if err != nil {
		return err
	}

	if err := s.sendTCPData(data); err != nil {
		return fmt.Errorf("failed to send trade request: %v", err)
	}

	return nil
}

func (s *tradeService) sendTCPData(data []byte) error {
	if s.tcpConn == nil {
		return errors.New("TCP connection not established")
	}

	_, err := s.tcpConn.Write(data)
	if err != nil {
		conn, err := net.DialTCP("tcp", nil, s.mt5TCPAddr)
		if err != nil {
			return fmt.Errorf("failed to reconnect to MT5 TCP server: %v", err)
		}
		s.tcpConn = conn
		_, err = s.tcpConn.Write(data)
		if err != nil {
			return fmt.Errorf("failed to send data after reconnect: %v", err)
		}
	}

	return nil
}

func (s *tradeService) HandleTradeResponse(response TradeResponse) error {
	tradeID, err := primitive.ObjectIDFromHex(response.TradeID)
	if err != nil {
		return errors.New("invalid trade ID")
	}

	trade, err := s.tradeRepo.GetTradeByID(tradeID)
	if err != nil {
		return err
	}
	if trade == nil {
		return errors.New("trade not found")
	}

	if response.Status == "MATCHED" {
		trade.Status = string(models.TradeStatusOpen)
		trade.MatchedTradeID = response.MatchedTradeID
	} else if response.Status == "PENDING" {
		trade.Status = string(models.TradeStatusPending)
	} else if response.Status == "EXPIRED" {
		trade.Status = string(models.TradeStatusClosed)
		trade.CloseTime = &time.Time{}
		*trade.CloseTime = time.Now()
	} else {
		trade.Status = string(models.TradeStatusClosed)
		trade.CloseTime = &time.Time{}
		*trade.CloseTime = time.Now()
	}

	err = s.tradeRepo.SaveTrade(trade)
	if err != nil {
		return err
	}

	metadata := map[string]interface{}{
		"trade_id":         response.TradeID,
		"status":           response.Status,
		"matched_trade_id": response.MatchedTradeID,
	}
	s.logService.LogAction(trade.UserID, "TradeResponse", "Trade status updated", "", metadata)

	return nil
}

func (s *tradeService) GetTrade(id string) (*models.TradeHistory, error) {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	return s.tradeRepo.GetTradeByID(objID)
}

func (s *tradeService) GetTradesByUserID(userID string) ([]*models.TradeHistory, error) {
	objID, err := primitive.ObjectIDFromHex(userID)
	if err != nil {
		return nil, err
	}
	return s.tradeRepo.GetTradesByUserID(objID)
}

func (s *tradeService) GetAllTrades() ([]*models.TradeHistory, error) {
	return s.tradeRepo.GetAllTrades()
}

type TradeResponse struct {
	TradeID        string `json:"trade_id"`
	UserID         string `json:"user_id"`
	Status         string `json:"status"`
	MatchedTradeID string `json:"matched_trade_id"`
	Timestamp      int64  `json:"timestamp"`
}

func (s *tradeService) RequestBalance(userID string) (float64, error) {
	_, err := primitive.ObjectIDFromHex(userID)
	if err != nil {
		return 0, errors.New("invalid user ID")
	}

	balanceRequest := map[string]interface{}{
		"type":      "balance_request",
		"user_id":   userID,
		"timestamp": time.Now().Unix(),
	}

	data, err := json.Marshal(balanceRequest)
	if err != nil {
		return 0, err
	}

	if err := s.sendTCPData(data); err != nil {
		return 0, fmt.Errorf("failed to send balance request: %v", err)
	}

	select {
	case response := <-s.balanceChan:
		if response.UserID != userID {
			return 0, errors.New("received balance response for wrong user")
		}
		if response.Error != "" {
			return 0, errors.New(response.Error)
		}
		return response.Balance, nil
	case <-time.After(5 * time.Second):
		return 0, errors.New("timeout waiting for balance response")
	}
}

func (s *tradeService) handleBalanceResponse(response BalanceResponse) error {
	userObjID, err := primitive.ObjectIDFromHex(response.UserID)
	if err != nil {
		return errors.New("invalid user ID in balance response")
	}

	metadata := map[string]interface{}{
		"user_id": response.UserID,
		"balance": response.Balance,
	}
	s.logService.LogAction(userObjID, "BalanceUpdate", "User balance updated from MT5", "", metadata)

	return nil
}
-e 
=== ./repository/copy_trade_repository.go ===

package repository

import (
	"context"
	"time"

	"github.com/mehrbod2002/fxtrader/internal/models"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

type CopyTradeRepository interface {
	SaveSubscription(subscription *models.CopyTradeSubscription) error
	GetSubscriptionByID(id primitive.ObjectID) (*models.CopyTradeSubscription, error)
	GetSubscriptionsByFollowerID(followerID string) ([]*models.CopyTradeSubscription, error)
	GetActiveSubscriptionsByLeaderID(leaderID string) ([]*models.CopyTradeSubscription, error)
	SaveCopyTrade(copyTrade *models.CopyTrade) error
}

type MongoCopyTradeRepository struct {
	collection *mongo.Collection
}

func NewCopyTradeRepository(client *mongo.Client, dbName, collectionName string) CopyTradeRepository {
	collection := client.Database(dbName).Collection(collectionName)
	return &MongoCopyTradeRepository{collection: collection}
}

func (r *MongoCopyTradeRepository) SaveSubscription(subscription *models.CopyTradeSubscription) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	subscription.ID = primitive.NewObjectID()
	subscription.CreatedAt = time.Now()
	_, err := r.collection.InsertOne(ctx, subscription)
	return err
}

func (r *MongoCopyTradeRepository) GetSubscriptionByID(id primitive.ObjectID) (*models.CopyTradeSubscription, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var subscription models.CopyTradeSubscription
	err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&subscription)
	if err == mongo.ErrNoDocuments {
		return nil, nil
	}
	return &subscription, err
}

func (r *MongoCopyTradeRepository) GetSubscriptionsByFollowerID(followerID string) ([]*models.CopyTradeSubscription, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var subscriptions []*models.CopyTradeSubscription
	cursor, err := r.collection.Find(ctx, bson.M{"follower_id": followerID})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)
	if err := cursor.All(ctx, &subscriptions); err != nil {
		return nil, err
	}
	return subscriptions, nil
}

func (r *MongoCopyTradeRepository) GetActiveSubscriptionsByLeaderID(leaderID string) ([]*models.CopyTradeSubscription, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var subscriptions []*models.CopyTradeSubscription
	cursor, err := r.collection.Find(ctx, bson.M{"leader_id": leaderID, "status": "ACTIVE"})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)
	if err := cursor.All(ctx, &subscriptions); err != nil {
		return nil, err
	}
	return subscriptions, nil
}

func (r *MongoCopyTradeRepository) SaveCopyTrade(copyTrade *models.CopyTrade) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	copyTrade.ID = primitive.NewObjectID()
	copyTrade.CreatedAt = time.Now()
	_, err := r.collection.InsertOne(ctx, copyTrade)
	return err
}
-e 
=== ./repository/trade_repository.go ===

package repository

import (
	"context"
	"time"

	"github.com/mehrbod2002/fxtrader/internal/models"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

type TradeRepository interface {
	SaveTrade(trade *models.TradeHistory) error
	GetTradeByID(id primitive.ObjectID) (*models.TradeHistory, error)
	GetTradesByUserID(userID primitive.ObjectID) ([]*models.TradeHistory, error)
	GetAllTrades() ([]*models.TradeHistory, error)
}

type MongoTradeRepository struct {
	collection *mongo.Collection
}

func NewTradeRepository(client *mongo.Client, dbName, collectionName string) TradeRepository {
	collection := client.Database(dbName).Collection(collectionName)
	return &MongoTradeRepository{collection: collection}
}

func (r *MongoTradeRepository) SaveTrade(trade *models.TradeHistory) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if trade.ID.IsZero() {
		trade.ID = primitive.NewObjectID()
		trade.OpenTime = time.Now()
		_, err := r.collection.InsertOne(ctx, trade)
		return err
	}

	filter := bson.M{"_id": trade.ID}
	update := bson.M{
		"$set": bson.M{
			"status":           trade.Status,
			"matched_trade_id": trade.MatchedTradeID,
			"close_time":       trade.CloseTime,
			"stop_loss":        trade.StopLoss,
			"take_profit":      trade.TakeProfit,
			"expiration":       trade.Expiration,
		},
	}
	_, err := r.collection.UpdateOne(ctx, filter, update)
	return err
}

func (r *MongoTradeRepository) GetTradeByID(id primitive.ObjectID) (*models.TradeHistory, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var trade models.TradeHistory
	err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&trade)
	if err == mongo.ErrNoDocuments {
		return nil, nil
	}
	return &trade, err
}

func (r *MongoTradeRepository) GetTradesByUserID(userID primitive.ObjectID) ([]*models.TradeHistory, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var trades []*models.TradeHistory
	cursor, err := r.collection.Find(ctx, bson.M{"user_id": userID})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)
	if err := cursor.All(ctx, &trades); err != nil {
		return nil, err
	}

	now := time.Now()
	for _, trade := range trades {
		if trade.Expiration != nil && trade.Expiration.Before(now) && trade.Status == "PENDING" {
			trade.Status = "EXPIRED"
			r.collection.UpdateOne(ctx, bson.M{"_id": trade.ID}, bson.M{"$set": bson.M{"status": "EXPIRED"}})
		}
	}
	return trades, nil
}

func (r *MongoTradeRepository) GetAllTrades() ([]*models.TradeHistory, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	cursor, err := r.collection.Find(ctx, bson.M{})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	var trades []*models.TradeHistory
	if err := cursor.All(ctx, &trades); err != nil {
		return nil, err
	}
	return trades, nil
}
