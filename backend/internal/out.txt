-e 
=== ./middleware/logger.go ===

package middleware

import (
	"fmt"
	"time"

	"github.com/gin-gonic/gin"
)

func LoggerMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		start := time.Now()
		path := c.Request.URL.Path
		method := c.Request.Method

		c.Next()

		latency := time.Since(start)
		status := c.Writer.Status()
		fmt.Printf("[%s] %s %s %d %v\n", time.Now().Format(time.RFC3339), method, path, status, latency)
	}
}
-e 
=== ./middleware/autrh.go ===

package middleware

import (
	"fxtrader/internal/config"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
)

func AdminAuthMiddleware(cfg *config.Config) gin.HandlerFunc {
	return func(c *gin.Context) {
		authHeader := c.GetHeader("Authorization")
		if authHeader == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header required"})
			c.Abort()
			return
		}

		parts := strings.SplitN(authHeader, " ", 2)
		if len(parts) != 2 || parts[0] != "Basic" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid authorization header"})
			c.Abort()
			return
		}

		credentials := strings.SplitN(parts[1], ":", 2)
		if len(credentials) != 2 {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials format"})
			c.Abort()
			return
		}

		if credentials[0] != cfg.AdminUser || credentials[1] != cfg.AdminPass {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
			c.Abort()
			return
		}

		c.Next()
	}
}
-e 
=== ./middleware/user_auth.go ===

package middleware

import (
	"fxtrader/internal/config"
	"fxtrader/internal/service"
	"net/http"
	"strings"
	"time"

	"github.com/dgrijalva/jwt-go"
	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

func UserAuthMiddleware(userService service.UserService) gin.HandlerFunc {
	return func(c *gin.Context) {
		authHeader := c.GetHeader("Authorization")
		if authHeader == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header required"})
			c.Abort()
			return
		}

		parts := strings.SplitN(authHeader, " ", 2)
		if len(parts) != 2 || parts[0] != "Bearer" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid authorization header; expected Bearer token"})
			c.Abort()
			return
		}

		tokenStr := parts[1]
		token, err := jwt.Parse(tokenStr, func(token *jwt.Token) (interface{}, error) {
			if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
				return nil, jwt.ErrSignatureInvalid
			}
			cfg, err := config.Load()
			if err != nil {
				return nil, err
			}
			return []byte(cfg.JWTSecret), nil
		})
		if err != nil || !token.Valid {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or expired token"})
			c.Abort()
			return
		}

		claims, ok := token.Claims.(jwt.MapClaims)
		if !ok {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token claims"})
			c.Abort()
			return
		}

		userIDStr, ok := claims["user_id"].(string)
		if !ok {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid user ID in token"})
			c.Abort()
			return
		}

		_, err = primitive.ObjectIDFromHex(userIDStr)
		if err != nil {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid user ID format"})
			c.Abort()
			return
		}

		user, err := userService.GetUser(userIDStr)
		if err != nil || user == nil {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "User not found"})
			c.Abort()
			return
		}

		c.Set("user_id", userIDStr)
		c.Next()
	}
}

func GenerateJWT(userID string, cfg *config.Config) (string, error) {
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"user_id": userID,
		"exp":     time.Now().Add(365 * 24 * time.Hour).Unix(),
		"iat":     time.Now().Unix(),
	})

	return token.SignedString([]byte(cfg.JWTSecret))
}
-e 
=== ./repository/transaction_repository.go ===

package repository

import (
	"context"
	"fxtrader/internal/models"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

type TransactionRepository interface {
	SaveTransaction(transaction *models.Transaction) error
	GetTransactionByID(id primitive.ObjectID) (*models.Transaction, error)
	GetTransactionsByUserID(userID primitive.ObjectID) ([]*models.Transaction, error)
	GetAllTransactions() ([]*models.Transaction, error)
	UpdateTransaction(id primitive.ObjectID, transaction *models.Transaction) error
}

type MongoTransactionRepository struct {
	collection *mongo.Collection
}

func NewTransactionRepository(client *mongo.Client, dbName, collectionName string) TransactionRepository {
	collection := client.Database(dbName).Collection(collectionName)
	return &MongoTransactionRepository{collection: collection}
}

func (r *MongoTransactionRepository) SaveTransaction(transaction *models.Transaction) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	transaction.ID = primitive.NewObjectID()
	transaction.RequestTime = time.Now()
	_, err := r.collection.InsertOne(ctx, transaction)
	return err
}

func (r *MongoTransactionRepository) GetTransactionByID(id primitive.ObjectID) (*models.Transaction, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var transaction models.Transaction
	err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&transaction)
	if err == mongo.ErrNoDocuments {
		return nil, nil
	}
	return &transaction, err
}

func (r *MongoTransactionRepository) GetTransactionsByUserID(userID primitive.ObjectID) ([]*models.Transaction, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var transactions []*models.Transaction
	cursor, err := r.collection.Find(ctx, bson.M{"user_id": userID}, options.Find().SetSort(bson.M{"request_time": -1}))
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)
	if err := cursor.All(ctx, &transactions); err != nil {
		return nil, err
	}
	return transactions, nil
}

func (r *MongoTransactionRepository) GetAllTransactions() ([]*models.Transaction, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var transactions []*models.Transaction
	cursor, err := r.collection.Find(ctx, bson.M{}, options.Find().SetSort(bson.M{"request_time": -1}))
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)
	if err := cursor.All(ctx, &transactions); err != nil {
		return nil, err
	}
	return transactions, nil
}

func (r *MongoTransactionRepository) UpdateTransaction(id primitive.ObjectID, transaction *models.Transaction) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	update := bson.M{
		"$set": bson.M{
			"status":        transaction.Status,
			"response_time": transaction.ResponseTime,
			"admin_note":    transaction.AdminNote,
		},
	}
	_, err := r.collection.UpdateOne(ctx, bson.M{"_id": id}, update)
	return err
}
-e 
=== ./repository/user_repository.go ===

package repository

// package repository
// (No changes needed; provided for reference)
import (
	"context"
	"fxtrader/internal/models"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

type UserRepository interface {
	SaveUser(user *models.UserAccount) error
	GetUserByID(id primitive.ObjectID) (*models.UserAccount, error)
	GetUserByTelegramID(telegramID string) (*models.UserAccount, error)
	GetAllUsers() ([]*models.UserAccount, error)
}

type MongoUserRepository struct {
	collection *mongo.Collection
}

func NewUserRepository(client *mongo.Client, dbName, collectionName string) UserRepository {
	collection := client.Database(dbName).Collection(collectionName)
	return &MongoUserRepository{collection: collection}
}

func (r *MongoUserRepository) SaveUser(user *models.UserAccount) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	_, err := r.collection.InsertOne(ctx, user)
	return err
}

func (r *MongoUserRepository) GetUserByID(id primitive.ObjectID) (*models.UserAccount, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var user models.UserAccount
	err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&user)
	if err == mongo.ErrNoDocuments {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return &user, nil
}

func (r *MongoUserRepository) GetUserByTelegramID(telegramID string) (*models.UserAccount, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var user models.UserAccount
	err := r.collection.FindOne(ctx, bson.M{"telegram_id": telegramID}).Decode(&user)
	if err == mongo.ErrNoDocuments {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return &user, nil
}

func (r *MongoUserRepository) GetAllUsers() ([]*models.UserAccount, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	cursor, err := r.collection.Find(ctx, bson.M{})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	var users []*models.UserAccount
	if err := cursor.All(ctx, &users); err != nil {
		return nil, err
	}
	return users, nil
}
-e 
=== ./repository/log_repository.go ===

package repository

import (
	"context"
	"fxtrader/internal/models"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

type LogRepository interface {
	SaveLog(log *models.LogEntry) error
	GetAllLogs() ([]*models.LogEntry, error)
	GetLogsByUserID(userID primitive.ObjectID) ([]*models.LogEntry, error)
}

type MongoLogRepository struct {
	collection *mongo.Collection
}

func NewLogRepository(client *mongo.Client, dbName, collectionName string) LogRepository {
	collection := client.Database(dbName).Collection(collectionName)
	return &MongoLogRepository{collection: collection}
}

func (r *MongoLogRepository) SaveLog(log *models.LogEntry) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	log.ID = primitive.NewObjectID()
	log.Timestamp = time.Now()
	_, err := r.collection.InsertOne(ctx, log)
	return err
}

func (r *MongoLogRepository) GetAllLogs() ([]*models.LogEntry, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var logs []*models.LogEntry
	cursor, err := r.collection.Find(ctx, bson.M{}, options.Find().SetSort(bson.M{"timestamp": -1}))
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)
	if err := cursor.All(ctx, &logs); err != nil {
		return nil, err
	}
	return logs, nil
}

func (r *MongoLogRepository) GetLogsByUserID(userID primitive.ObjectID) ([]*models.LogEntry, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var logs []*models.LogEntry
	cursor, err := r.collection.Find(ctx, bson.M{"user_id": userID}, options.Find().SetSort(bson.M{"timestamp": -1}))
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)
	if err := cursor.All(ctx, &logs); err != nil {
		return nil, err
	}
	return logs, nil
}
-e 
=== ./repository/symbol_repository.go ===

package repository

import (
	"context"
	"fxtrader/internal/models"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

type SymbolRepository interface {
	SaveSymbol(symbol *models.Symbol) error
	GetSymbolByID(id primitive.ObjectID) (*models.Symbol, error)
	GetAllSymbols() ([]*models.Symbol, error)
	UpdateSymbol(id primitive.ObjectID, symbol *models.Symbol) error
	DeleteSymbol(id primitive.ObjectID) error
}

type MongoSymbolRepository struct {
	collection *mongo.Collection
}

func NewSymbolRepository(client *mongo.Client, dbName, collectionName string) SymbolRepository {
	collection := client.Database(dbName).Collection(collectionName)
	return &MongoSymbolRepository{collection: collection}
}

func (r *MongoSymbolRepository) SaveSymbol(symbol *models.Symbol) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	symbol.ID = primitive.NewObjectID()
	symbol.CreatedAt = time.Now()
	symbol.UpdatedAt = time.Now()
	_, err := r.collection.InsertOne(ctx, symbol)
	return err
}

func (r *MongoSymbolRepository) GetSymbolByID(id primitive.ObjectID) (*models.Symbol, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var symbol models.Symbol
	err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&symbol)
	if err == mongo.ErrNoDocuments {
		return nil, nil
	}
	return &symbol, err
}

func (r *MongoSymbolRepository) GetAllSymbols() ([]*models.Symbol, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var symbols []*models.Symbol
	cursor, err := r.collection.Find(ctx, bson.M{})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)
	if err := cursor.All(ctx, &symbols); err != nil {
		return nil, err
	}
	return symbols, nil
}

func (r *MongoSymbolRepository) UpdateSymbol(id primitive.ObjectID, symbol *models.Symbol) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	symbol.UpdatedAt = time.Now()
	update := bson.M{"$set": symbol}
	_, err := r.collection.UpdateOne(ctx, bson.M{"_id": id}, update)
	return err
}

func (r *MongoSymbolRepository) DeleteSymbol(id primitive.ObjectID) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	_, err := r.collection.DeleteOne(ctx, bson.M{"_id": id})
	return err
}
-e 
=== ./repository/rule_repository.go ===

package repository

import (
	"context"
	"fxtrader/internal/models"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

type RuleRepository interface {
	SaveRule(rule *models.Rule) error
	GetRuleByID(id primitive.ObjectID) (*models.Rule, error)
	GetAllRules() ([]*models.Rule, error)
	UpdateRule(id primitive.ObjectID, rule *models.Rule) error
	DeleteRule(id primitive.ObjectID) error
}

type MongoRuleRepository struct {
	collection *mongo.Collection
}

func NewRuleRepository(client *mongo.Client, dbName, collectionName string) RuleRepository {
	collection := client.Database(dbName).Collection(collectionName)
	return &MongoRuleRepository{collection: collection}
}

func (r *MongoRuleRepository) SaveRule(rule *models.Rule) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	rule.ID = primitive.NewObjectID()
	rule.CreatedAt = time.Now()
	_, err := r.collection.InsertOne(ctx, rule)
	return err
}

func (r *MongoRuleRepository) GetRuleByID(id primitive.ObjectID) (*models.Rule, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var rule models.Rule
	err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&rule)
	if err == mongo.ErrNoDocuments {
		return nil, nil
	}
	return &rule, err
}

func (r *MongoRuleRepository) GetAllRules() ([]*models.Rule, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var rules []*models.Rule
	cursor, err := r.collection.Find(ctx, bson.M{})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)
	if err := cursor.All(ctx, &rules); err != nil {
		return nil, err
	}
	return rules, nil
}

func (r *MongoRuleRepository) UpdateRule(id primitive.ObjectID, rule *models.Rule) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	update := bson.M{"$set": bson.M{"content": rule.Content}}
	_, err := r.collection.UpdateOne(ctx, bson.M{"_id": id}, update)
	return err
}

func (r *MongoRuleRepository) DeleteRule(id primitive.ObjectID) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	_, err := r.collection.DeleteOne(ctx, bson.M{"_id": id})
	return err
}
-e 
=== ./repository/trade_repository.go ===

package repository

import (
	"context"
	"fxtrader/internal/models"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

type TradeRepository interface {
	SaveTrade(trade *models.TradeHistory) error
	GetTradeByID(id primitive.ObjectID) (*models.TradeHistory, error)
	GetTradesByUserID(userID primitive.ObjectID) ([]*models.TradeHistory, error)
	GetAllTrades() ([]*models.TradeHistory, error)
}

type MongoTradeRepository struct {
	collection *mongo.Collection
}

func NewTradeRepository(client *mongo.Client, dbName, collectionName string) TradeRepository {
	collection := client.Database(dbName).Collection(collectionName)
	return &MongoTradeRepository{collection: collection}
}

func (r *MongoTradeRepository) SaveTrade(trade *models.TradeHistory) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	trade.ID = primitive.NewObjectID()
	trade.OpenTime = time.Now()
	_, err := r.collection.InsertOne(ctx, trade)
	return err
}

func (r *MongoTradeRepository) GetTradeByID(id primitive.ObjectID) (*models.TradeHistory, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var trade models.TradeHistory
	err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&trade)
	if err == mongo.ErrNoDocuments {
		return nil, nil
	}
	return &trade, err
}

func (r *MongoTradeRepository) GetTradesByUserID(userID primitive.ObjectID) ([]*models.TradeHistory, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var trades []*models.TradeHistory
	cursor, err := r.collection.Find(ctx, bson.M{"user_id": userID})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)
	if err := cursor.All(ctx, &trades); err != nil {
		return nil, err
	}
	return trades, nil
}

func (r *MongoTradeRepository) GetAllTrades() ([]*models.TradeHistory, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	cursor, err := r.collection.Find(ctx, bson.M{})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	var trades []*models.TradeHistory
	if err := cursor.All(ctx, &trades); err != nil {
		return nil, err
	}
	return trades, nil
}
-e 
=== ./repository/price_repository.go ===

package repository

import (
	"fxtrader/internal/models"
	"sync"
)

type PriceRepository interface {
	SavePrice(data *models.PriceData) error
}

type InMemoryPriceRepository struct {
	prices []*models.PriceData
	mu     sync.Mutex
}

func NewPriceRepository() PriceRepository {
	return &InMemoryPriceRepository{
		prices: make([]*models.PriceData, 0),
	}
}

func (r *InMemoryPriceRepository) SavePrice(data *models.PriceData) error {
	r.mu.Lock()
	defer r.mu.Unlock()
	r.prices = append(r.prices, data)
	return nil
}
-e 
=== ./config/config.go ===

package config

import (
	"errors"
	"os"
	"strconv"

	"github.com/joho/godotenv"
)

type Config struct {
	Address    string
	Port       int
	BaseURL    string
	MongoURI   string
	AdminUser  string
	AdminPass  string
	JWTSecret  string
	MT5Host    string
	MT5Port    int
	ListenPort int
}

func Load() (*Config, error) {
	_ = godotenv.Load()

	portStr := os.Getenv("PORT")
	if portStr == "" {
		portStr = "8080"
	}
	port, err := strconv.Atoi(portStr)
	if err != nil {
		return nil, errors.New("invalid PORT value")
	}

	address := os.Getenv("ADDRESS")
	if address == "" {
		address = "0.0.0.0"
	}

	baseURL := os.Getenv("BASE_URL")
	if baseURL == "" {
		baseURL = "http://localhost:" + portStr
	}

	mongoURI := os.Getenv("MONGO_URI")
	if mongoURI == "" {
		mongoURI = "mongodb://127.0.0.1:27017"
	}

	adminUser := os.Getenv("ADMIN_USER")
	if adminUser == "" {
		adminUser = "admin"
	}

	adminPass := os.Getenv("ADMIN_PASS")
	if adminPass == "" {
		adminPass = "admin"
	}

	jwtSecret := os.Getenv("JWT_SECRET")
	if jwtSecret == "" {
		jwtSecret = "default_jwt_secret"
	}

	mt5Host := os.Getenv("MT5_HOST")
	if mt5Host == "" {
		mt5Host = "127.0.0.1"
	}

	mt5PortStr := os.Getenv("MT5_PORT")
	if mt5PortStr == "" {
		mt5PortStr = "5000"
	}
	mt5Port, err := strconv.Atoi(mt5PortStr)
	if err != nil {
		return nil, errors.New("invalid MT5_PORT value")
	}

	listenPortStr := os.Getenv("LISTEN_PORT")
	if listenPortStr == "" {
		listenPortStr = "5001"
	}
	listenPort, err := strconv.Atoi(listenPortStr)
	if err != nil {
		return nil, errors.New("invalid LISTEN_PORT value")
	}

	return &Config{
		Address:    address,
		Port:       port,
		BaseURL:    baseURL,
		MongoURI:   mongoURI,
		AdminUser:  adminUser,
		AdminPass:  adminPass,
		JWTSecret:  jwtSecret,
		MT5Host:    mt5Host,
		MT5Port:    mt5Port,
		ListenPort: listenPort,
	}, nil
}
-e 
=== ./config/admin.go ===

package config

import (
	"context"
	"fxtrader/internal/models"
	"fxtrader/internal/repository"
	"log"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
	"golang.org/x/crypto/bcrypt"
)

func EnsureAdminUser(userRepo repository.UserRepository, adminUser, adminPass string) error {
	_, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	user, err := userRepo.GetUserByTelegramID("admin_" + adminUser)
	if err == nil && user != nil {
		log.Println("Admin user already exists")
		return nil
	}

	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(adminPass), bcrypt.DefaultCost)
	if err != nil {
		return err
	}

	admin := &models.UserAccount{
		ID:               primitive.NewObjectID(),
		Username:         adminUser,
		FullName:         "Admin User",
		AccountType:      "admin",
		RegistrationDate: time.Now().Format(time.RFC3339),
		TelegramID:       "admin_" + adminUser,
		Password:         string(hashedPassword),
	}

	err = userRepo.SaveUser(admin)
	if err != nil {
		return err
	}

	log.Println("Default admin user created")
	return nil
}
-e 
=== ./models/trade.go ===

package models

import (
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type TradeType string

const (
	TradeTypeBuy  TradeType = "BUY"
	TradeTypeSell TradeType = "SELL"
)

type TradeStatus string

const (
	TradeStatusOpen    TradeStatus = "OPEN"
	TradeStatusClosed  TradeStatus = "CLOSED"
	TradeStatusPending TradeStatus = "PENDING"
)

type TradeHistory struct {
	ID         primitive.ObjectID `json:"_id,omitempty" bson:"_id,omitempty"`
	UserID     primitive.ObjectID `json:"user_id" bson:"user_id"`
	SymbolName string             `json:"symbol_name" bson:"symbol_name"`
	TradeType  TradeType          `json:"trade_type" bson:"trade_type"`
	Leverage   int                `json:"leverage" bson:"leverage"`
	Volume     float64            `json:"volume" bson:"volume"`
	EntryPrice float64            `json:"entry_price" bson:"entry_price"`
	ClosePrice float64            `json:"close_price,omitempty" bson:"close_price,omitempty"`
	Status     TradeStatus        `json:"status" bson:"status"`
	ProfitLoss float64            `json:"profit_loss,omitempty" bson:"profit_loss,omitempty"`
	OpenTime   time.Time          `json:"open_time" bson:"open_time"`
	CloseTime  *time.Time         `json:"close_time,omitempty" bson:"close_time,omitempty"`
}
-e 
=== ./models/log.go ===

package models

import (
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type LogEntry struct {
	ID          primitive.ObjectID     `json:"_id,omitempty" bson:"_id,omitempty"`
	UserID      primitive.ObjectID     `json:"user_id,omitempty" bson:"user_id,omitempty"`
	Action      string                 `json:"action" bson:"action"`
	Description string                 `json:"description" bson:"description"`
	IPAddress   string                 `json:"ip_address,omitempty" bson:"ip_address,omitempty"`
	Timestamp   time.Time              `json:"timestamp" bson:"timestamp"`
	Metadata    map[string]interface{} `json:"metadata,omitempty" bson:"metadata,omitempty"`
}
-e 
=== ./models/user.go ===

package models

import (
	"go.mongodb.org/mongo-driver/bson/primitive"
)

type UserAccount struct {
	ID               primitive.ObjectID `json:"_id,omitempty" bson:"_id,omitempty"`
	Username         string             `json:"username" bson:"username"`
	FullName         string             `json:"full_name" bson:"full_name"`
	PhoneNumber      string             `json:"phone_number" bson:"phone_number"`
	CardNumber       string             `json:"card_number" bson:"card_number"`
	NationalID       string             `json:"national_id" bson:"national_id"`
	Citizenship      string             `json:"citizenship" bson:"citizenship"`
	AccountType      string             `json:"account_type" bson:"account_type"`
	AccountName      string             `json:"account_name" bson:"account_name"`
	Balance          float64            `json:"balance" bson:"balance"`
	Bonus            float64            `json:"bonus" bson:"bonus"`
	Leverage         int                `json:"leverage" bson:"leverage"`
	TradeType        string             `json:"trade_type" bson:"trade_type"`
	RegistrationDate string             `json:"registration_date" bson:"registration_date"`
	WalletAddress    string             `json:"wallet_address" bson:"wallet_address"`
	TelegramID       string             `json:"telegram_id" bson:"telegram_id"`
}
-e 
=== ./models/rules.go ===

package models

import (
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type Rule struct {
	ID        primitive.ObjectID `json:"_id,omitempty" bson:"_id,omitempty"`
	Content   string             `json:"content" bson:"content"`
	CreatedAt time.Time          `json:"created_at" bson:"created_at"`
}
-e 
=== ./models/symbol.go ===

package models

import (
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type Symbol struct {
	ID             primitive.ObjectID `json:"_id,omitempty" bson:"_id,omitempty"`
	SymbolName     string             `json:"symbol_name" bson:"symbol_name"`
	DisplayName    string             `json:"display_name" bson:"display_name"`
	Category       string             `json:"category" bson:"category"`
	DeniedAccounts []string           `json:"denied_accounts" bson:"denied_accounts"`
	Leverage       int                `json:"leverage" bson:"leverage"`
	MinLot         float64            `json:"min_lot" bson:"min_lot"`
	MaxLot         float64            `json:"max_lot" bson:"max_lot"`
	Spread         float64            `json:"spread" bson:"spread"`
	Commission     float64            `json:"commission" bson:"commission"`
	TradingHours   TradingHours       `json:"trading_hours" bson:"trading_hours"`
	IsTradingOpen  bool               `json:"is_trading_open" bson:"is_trading_open"`
	CreatedAt      time.Time          `json:"created_at" bson:"created_at"`
	UpdatedAt      time.Time          `json:"updated_at" bson:"updated_at"`
}

type TradingHours struct {
	Unlimited bool      `json:"unlimited" bson:"unlimited"`
	OpenTime  time.Time `json:"open_time,omitempty" bson:"open_time,omitempty"`
	CloseTime time.Time `json:"close_time,omitempty" bson:"close_time,omitempty"`
}
-e 
=== ./models/client.go ===

package models

import (
	"sync"

	"github.com/gorilla/websocket"
)

type Client struct {
	ID      string
	Conn    *websocket.Conn
	Send    chan *PriceData
	Symbols map[string]bool
	mu      sync.RWMutex
}

func NewClient(id string, conn *websocket.Conn) *Client {
	return &Client{
		ID:      id,
		Conn:    conn,
		Send:    make(chan *PriceData, 256),
		Symbols: make(map[string]bool),
	}
}

func (c *Client) Subscribe(symbol string) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.Symbols[symbol] = true
}

func (c *Client) Unsubscribe(symbol string) {
	c.mu.Lock()
	defer c.mu.Unlock()
	delete(c.Symbols, symbol)
}

func (c *Client) IsSubscribed(symbol string) bool {
	c.mu.RLock()
	defer c.mu.RUnlock()
	_, ok := c.Symbols[symbol]
	return ok
}

func (c *Client) Close() {
	c.Conn.Close()
	close(c.Send)
}

type SocketMessage struct {
	Action string `json:"action"`
	Symbol string `json:"symbol"`
}

type SubscriptionResponse struct {
	Status  string   `json:"status"`
	Message string   `json:"message"`
	Symbols []string `json:"symbols,omitempty"`
}

type ErrorResponse struct {
	Error string `json:"error"`
}
-e 
=== ./models/transaction.go ===

package models

import (
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type TransactionType string

const (
	TransactionTypeDeposit    TransactionType = "DEPOSIT"
	TransactionTypeWithdrawal TransactionType = "WITHDRAWAL"
)

type PaymentMethod string

const (
	PaymentMethodCardToCard     PaymentMethod = "CARD_TO_CARD"
	PaymentMethodDepositReceipt PaymentMethod = "DEPOSIT_RECEIPT"
)

type TransactionStatus string

const (
	TransactionStatusPending  TransactionStatus = "PENDING"
	TransactionStatusApproved TransactionStatus = "APPROVED"
	TransactionStatusRejected TransactionStatus = "REJECTED"
)

type Transaction struct {
	ID              primitive.ObjectID `json:"_id,omitempty" bson:"_id,omitempty"`
	UserID          primitive.ObjectID `json:"user_id" bson:"user_id"`
	TransactionType TransactionType    `json:"transaction_type" bson:"transaction_type"`
	PaymentMethod   PaymentMethod      `json:"payment_method" bson:"payment_method"`
	Amount          float64            `json:"amount" bson:"amount"`
	Status          TransactionStatus  `json:"status" bson:"status"`
	ReceiptImage    string             `json:"receipt_image,omitempty" bson:"receipt_image,omitempty"`
	RequestTime     time.Time          `json:"request_time" bson:"request_time"`
	ResponseTime    *time.Time         `json:"response_time,omitempty" bson:"response_time,omitempty"`
	AdminNote       string             `json:"admin_note,omitempty" bson:"admin_note,omitempty"`
}
-e 
=== ./models/price.go ===

package models

type PriceData struct {
	Symbol    string  `json:"symbol"`
	Ask       float64 `json:"ask"`
	Bid       float64 `json:"bid"`
	Timestamp int64   `json:"timestamp"`
}
-e 
=== ./api/log_handlers.go ===

package api

import (
	"fxtrader/internal/service"
	"net/http"

	"github.com/gin-gonic/gin"
)

type LogHandler struct {
	logService service.LogService
}

func NewLogHandler(logService service.LogService) *LogHandler {
	return &LogHandler{logService: logService}
}

// @Summary Get all logs
// @Description Retrieves a list of all system logs (admin only)
// @Tags Logs
// @Produce json
// @Security BasicAuth
// @Success 200 {array} models.LogEntry
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 500 {object} map[string]string "Failed to retrieve logs"
// @Router /admin/logs [get]
func (h *LogHandler) GetAllLogs(c *gin.Context) {
	logs, err := h.logService.GetAllLogs()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve logs"})
		return
	}
	c.JSON(http.StatusOK, logs)
}

// @Summary Get logs by user ID
// @Description Retrieves logs associated with a specific user ID (admin only)
// @Tags Logs
// @Produce json
// @Security BasicAuth
// @Param user_id path string true "User ID"
// @Success 200 {array} models.LogEntry
// @Failure 400 {object} map[string]string "Invalid user ID"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Router /admin/logs/user/{user_id} [get]
func (h *LogHandler) GetLogsByUser(c *gin.Context) {
	userID := c.Param("user_id")
	logs, err := h.logService.GetLogsByUserID(userID)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
		return
	}
	c.JSON(http.StatusOK, logs)
}
-e 
=== ./api/symbol_handlers.go ===

package api

import (
	"fxtrader/internal/models"
	"fxtrader/internal/service"
	"net/http"

	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

type SymbolHandler struct {
	symbolService service.SymbolService
	logService    service.LogService
}

func NewSymbolHandler(symbolService service.SymbolService, logService service.LogService) *SymbolHandler {
	return &SymbolHandler{symbolService: symbolService, logService: logService}
}

// CreateSymbol creates a new symbol
// @Summary Create a new symbol
// @Description Adds a new trading symbol to the system (admin only)
// @Tags Symbols
// @Accept json
// @Produce json
// @Security BasicAuth
// @Param symbol body models.Symbol true "Symbol data"
// @Success 201 {object} map[string]string "Symbol created"
// @Failure 400 {object} map[string]string "Invalid JSON"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 500 {object} map[string]string "Failed to create symbol"
// @Router /admin/symbols [post]
func (h *SymbolHandler) CreateSymbol(c *gin.Context) {
	var symbol models.Symbol
	if err := c.ShouldBindJSON(&symbol); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	if err := h.symbolService.CreateSymbol(&symbol); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create symbol"})
		return
	}

	metadata := map[string]interface{}{
		"symbol_id":   symbol.ID.Hex(),
		"symbol_name": symbol.SymbolName,
	}
	h.logService.LogAction(primitive.ObjectID{}, "CreateSymbol", "Symbol created", c.ClientIP(), metadata)

	c.JSON(http.StatusCreated, gin.H{"status": "Symbol created", "symbol_id": symbol.ID.Hex()})
}

// @Summary Get symbol by ID
// @Description Retrieves details of a trading symbol by ID
// @Tags Symbols
// @Produce json
// @Param id path string true "Symbol ID"
// @Success 200 {object} models.Symbol
// @Failure 400 {object} map[string]string "Invalid symbol ID"
// @Failure 404 {object} map[string]string "Symbol not found"
// @Router /symbols/{id} [get]
func (h *SymbolHandler) GetSymbol(c *gin.Context) {
	id := c.Param("id")
	symbol, err := h.symbolService.GetSymbol(id)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid symbol ID"})
		return
	}
	if symbol == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Symbol not found"})
		return
	}

	metadata := map[string]interface{}{
		"symbol_id": id,
	}
	h.logService.LogAction(primitive.ObjectID{}, "GetSymbol", "Symbol data retrieved", c.ClientIP(), metadata)

	c.JSON(http.StatusOK, symbol)
}

// GetAllSymbols retrieves all symbols
// @Summary Get all symbols
// @Description Retrieves a list of all trading symbols
// @Tags Symbols
// @Produce json
// @Success 200 {array} models.Symbol
// @Failure 500 {object} map[string]string "Failed to retrieve symbols"
// @Router /symbols [get]
func (h *SymbolHandler) GetAllSymbols(c *gin.Context) {
	symbols, err := h.symbolService.GetAllSymbols()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve symbols"})
		return
	}

	h.logService.LogAction(primitive.ObjectID{}, "GetAllSymbols", "All symbols retrieved", c.ClientIP(), nil)

	c.JSON(http.StatusOK, symbols)
}

// @Summary Update a symbol
// @Description Updates the details of an existing trading symbol (admin only)
// @Tags Symbols
// @Accept json
// @Produce json
// @Security BasicAuth
// @Param id path string true "Symbol ID"
// @Param symbol body models.Symbol true "Updated symbol data"
// @Success 200 {object} map[string]string "Symbol updated"
// @Failure 400 {object} map[string]string "Invalid JSON"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 500 {object} map[string]string "Failed to update symbol"
// @Router /admin/symbols/{id} [put]
func (h *SymbolHandler) UpdateSymbol(c *gin.Context) {
	id := c.Param("id")
	var symbol models.Symbol
	if err := c.ShouldBindJSON(&symbol); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	if err := h.symbolService.UpdateSymbol(id, &symbol); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update symbol"})
		return
	}

	metadata := map[string]interface{}{
		"symbol_id": id,
	}
	h.logService.LogAction(primitive.ObjectID{}, "UpdateSymbol", "Symbol updated", c.ClientIP(), metadata)

	c.JSON(http.StatusOK, gin.H{"status": "Symbol updated"})
}

// @Summary Delete a symbol
// @Description Removes a trading symbol from the system (admin only)
// @Tags Symbols
// @Produce json
// @Security BasicAuth
// @Param id path string true "Symbol ID"
// @Success 200 {object} map[string]string "Symbol deleted"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 500 {object} map[string]string "Failed to delete symbol"
// @Router /admin/symbols/{id} [delete]
func (h *SymbolHandler) DeleteSymbol(c *gin.Context) {
	id := c.Param("id")
	if err := h.symbolService.DeleteSymbol(id); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete symbol"})
		return
	}

	metadata := map[string]interface{}{
		"symbol_id": id,
	}
	h.logService.LogAction(primitive.ObjectID{}, "DeleteSymbol", "Symbol deleted", c.ClientIP(), metadata)

	c.JSON(http.StatusOK, gin.H{"status": "Symbol deleted"})
}
-e 
=== ./api/transaction_handlers.go ===

package api

import (
	"fxtrader/internal/models"
	"fxtrader/internal/service"
	"net/http"

	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

type TransactionHandler struct {
	transactionService service.TransactionService
	logService         service.LogService
}

func NewTransactionHandler(transactionService service.TransactionService, logService service.LogService) *TransactionHandler {
	return &TransactionHandler{transactionService: transactionService, logService: logService}
}

// @Summary Request a new transaction
// @Description Allows a user to request a deposit or withdrawal
// @Tags Transactions
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param transaction body TransactionRequest true "Transaction data"
// @Success 201 {object} map[string]string "Transaction requested"
// @Failure 400 {object} map[string]string "Invalid JSON or parameters"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 500 {object} map[string]string "Failed to create transaction"
// @Router /transactions [post]
func (h *TransactionHandler) CreateTransaction(c *gin.Context) {
	var req TransactionRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	userID := c.GetString("user_id")
	transaction := &models.Transaction{
		TransactionType: req.TransactionType,
		PaymentMethod:   req.PaymentMethod,
		Amount:          req.Amount,
		ReceiptImage:    req.ReceiptImage,
	}

	if err := h.transactionService.CreateTransaction(userID, transaction); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"status": "Transaction requested", "transaction_id": transaction.ID.Hex()})
}

// @Summary Get user transactions
// @Description Retrieves all transactions for the authenticated user
// @Tags Transactions
// @Produce json
// @Security BearerAuth
// @Success 200 {array} models.Transaction
// @Failure 400 {object} map[string]string "Invalid user ID"
// @Failure 500 {object} map[string]string "Failed to retrieve transactions"
// @Router /transactions [get]
func (h *TransactionHandler) GetUserTransactions(c *gin.Context) {
	userID := c.GetString("user_id")
	transactions, err := h.transactionService.GetTransactionsByUserID(userID)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusOK, transactions)
}

// @Summary Get all transactions
// @Description Retrieves a list of all transactions (admin only)
// @Tags Transactions
// @Produce json
// @Security BasicAuth
// @Success 200 {array} models.Transaction
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 500 {object} map[string]string "Failed to retrieve transactions"
// @Router /admin/transactions [get]
func (h *TransactionHandler) GetAllTransactions(c *gin.Context) {
	transactions, err := h.transactionService.GetAllTransactions()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve transactions"})
		return
	}
	c.JSON(http.StatusOK, transactions)
}

// @Summary Get transactions by user ID
// @Description Retrieves transactions for a specific user (admin only)
// @Tags Transactions
// @Produce json
// @Security BasicAuth
// @Param user_id path string true "User ID"
// @Success 200 {array} models.Transaction
// @Failure 400 {object} map[string]string "Invalid user ID"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 500 {object} map[string]string "Failed to retrieve transactions"
// @Router /admin/transactions/user/{user_id} [get]
func (h *TransactionHandler) GetTransactionsByUser(c *gin.Context) {
	userID := c.Param("user_id")
	transactions, err := h.transactionService.GetTransactionsByUserID(userID)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusOK, transactions)
}

// @Summary Get transaction by ID
// @Description Retrieves details of a specific transaction by its ID (admin only)
// @Tags Transactions
// @Produce json
// @Security BearerAuth
// @Param id path string true "Transaction ID"
// @Success 200 {object} models.Transaction
// @Failure 400 {object} map[string]string "Invalid transaction ID"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 403 {object} map[string]string "Forbidden (non-admin)"
// @Failure 404 {object} map[string]string "Transaction not found"
// @Router /api/v1/transactions/{id} [get]
func (h *TransactionHandler) GetTransactionByID(c *gin.Context) {
	transactionID := c.Param("id")
	transaction, err := h.transactionService.GetTransactionByID(transactionID)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid transaction ID"})
		return
	}
	if transaction == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Transaction not found"})
		return
	}

	adminID := c.GetString("user_id")
	adminObjID, _ := primitive.ObjectIDFromHex(adminID)
	metadata := map[string]interface{}{
		"admin_id":       adminID,
		"transaction_id": transactionID,
	}
	h.logService.LogAction(adminObjID, "GetTransactionByID", "Transaction data retrieved", c.ClientIP(), metadata)

	c.JSON(http.StatusOK, transaction)
}

// @Summary Review a transaction
// @Description Approves or rejects a transaction with an optional note (admin only)
// @Tags Transactions
// @Accept json
// @Produce json
// @Security BasicAuth
// @Param id path string true "Transaction ID"
// @Param review body TransactionReviewRequest true "Review data"
// @Success 200 {object} map[string]string "Transaction reviewed"
// @Failure 400 {object} map[string]string "Invalid JSON or parameters"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 500 {object} map[string]string "Failed to review transaction"
// @Router /admin/transactions/{id} [put]
func (h *TransactionHandler) ReviewTransaction(c *gin.Context) {
	id := c.Param("id")
	var req TransactionReviewRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	if err := h.transactionService.ReviewTransaction(id, req.Status, req.AdminNote); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	metadata := map[string]interface{}{
		"transaction_id": id,
		"status":         req.Status,
	}
	h.logService.LogAction(primitive.ObjectID{}, "ReviewTransaction", "Transaction reviewed", c.ClientIP(), metadata)

	c.JSON(http.StatusOK, gin.H{"status": "Transaction reviewed"})
}

type TransactionRequest struct {
	TransactionType models.TransactionType `json:"transaction_type" binding:"required,oneof=DEPOSIT WITHDRAWAL"`
	PaymentMethod   models.PaymentMethod   `json:"payment_method" binding:"required,oneof=CARD_TO_CARD DEPOSIT_RECEIPT"`
	Amount          float64                `json:"amount" binding:"required,gt=0"`
	ReceiptImage    string                 `json:"receipt_image,omitempty"`
}

type TransactionReviewRequest struct {
	Status    models.TransactionStatus `json:"status" binding:"required,oneof=APPROVED REJECTED"`
	AdminNote string                   `json:"admin_note,omitempty"`
}
-e 
=== ./api/docs.go ===

package api

// @title FXTrader API
// @version 1.0
// @description API for the FXTrader app
// @host localhost:8080
// @BasePath /api
// @schemes http
// @securityDefinitions.basic BasicAuth
func init() {}
-e 
=== ./api/handlers.go ===

package api

import (
	"fxtrader/internal/models"
	"fxtrader/internal/service"
	"net/http"

	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

type PriceHandler struct {
	priceService service.PriceService
	logService   service.LogService
}

func NewPriceHandler(priceService service.PriceService, logService service.LogService) *PriceHandler {
	return &PriceHandler{priceService: priceService, logService: logService}
}

// @Summary Process new price data
// @Description Receives and processes price data for a trading symbol
// @Tags Prices
// @Accept json
// @Produce json
// @Param priceData body models.PriceData true "Price data"
// @Success 200 {object} map[string]string "Price received"
// @Failure 400 {object} map[string]string "Invalid JSON"
// @Failure 500 {object} map[string]string "Failed to process price"
// @Router /prices [post]
func (h *PriceHandler) HandlePrice(c *gin.Context) {
	var priceData models.PriceData
	if err := c.ShouldBindJSON(&priceData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	if err := h.priceService.ProcessPrice(&priceData); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to process price"})
		return
	}

	metadata := map[string]interface{}{
		"symbol":    priceData.Symbol,
		"ask":       priceData.Ask,
		"bid":       priceData.Bid,
		"timestamp": priceData.Timestamp,
	}
	h.logService.LogAction(primitive.ObjectID{}, "ProcessPrice", "Processed new price data", c.ClientIP(), metadata)

	c.JSON(http.StatusOK, gin.H{"status": "Price received"})
}
-e 
=== ./api/trade_handlers.go ===

package api

import (
	"fxtrader/internal/models"
	"fxtrader/internal/service"
	"net/http"

	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

type TradeHandler struct {
	tradeService service.TradeService
	logService   service.LogService
}

func NewTradeHandler(tradeService service.TradeService, logService service.LogService) *TradeHandler {
	return &TradeHandler{tradeService: tradeService, logService: logService}
}

// @Summary Place a new trade
// @Description Allows an authenticated user to place a trade order
// @Tags Trades
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param trade body TradeRequest true "Trade order data"
// @Success 201 {object} map[string]string "Trade placed"
// @Failure 400 {object} map[string]string "Invalid JSON or parameters"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 500 {object} map[string]string "Server error"
// @Router /api/trades [post]
func (h *TradeHandler) PlaceTrade(c *gin.Context) {
	var req TradeRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	userID := c.GetString("user_id")
	trade, err := h.tradeService.PlaceTrade(userID, req.SymbolName, req.TradeType, req.Leverage, req.Volume, req.EntryPrice)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	metadata := map[string]interface{}{
		"user_id":    userID,
		"trade_id":   trade.ID.Hex(),
		"symbol":     req.SymbolName,
		"trade_type": req.TradeType,
	}
	h.logService.LogAction(trade.UserID, "PlaceTrade", "Trade order placed", c.ClientIP(), metadata)

	c.JSON(http.StatusCreated, gin.H{"status": "Trade placed", "trade_id": trade.ID.Hex()})
}

// @Summary Get user trades
// @Description Retrieves a list of trades for the authenticated user
// @Tags Trades
// @Produce json
// @Security BearerAuth
// @Success 200 {array} models.TradeHistory
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 500 {object} map[string]string "Server error"
// @Router /api/trades [get]
func (h *TradeHandler) GetUserTrades(c *gin.Context) {
	userID := c.GetString("user_id")
	trades, err := h.tradeService.GetTradesByUserID(userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve trades"})
		return
	}

	userObjID, _ := primitive.ObjectIDFromHex(userID)
	metadata := map[string]interface{}{
		"user_id": userID,
		"count":   len(trades),
	}
	h.logService.LogAction(userObjID, "GetUserTrades", "Retrieved user trades", c.ClientIP(), metadata)

	c.JSON(http.StatusOK, trades)
}

// @Summary Get trade by ID
// @Description Retrieves details of a specific trade by its ID (user or admin)
// @Tags Trades
// @Produce json
// @Security BearerAuth
// @Param id path string true "Trade ID"
// @Success 200 {object} models.TradeHistory
// @Failure 400 {object} map[string]string "Invalid trade ID"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 403 {object} map[string]string "Forbidden (trade belongs to another user)"
// @Failure 404 {object} map[string]string "Trade not found"
// @Router /api/trades/{id} [get]
func (h *TradeHandler) GetTrade(c *gin.Context) {
	tradeID := c.Param("id")
	userID := c.GetString("user_id")
	isAdmin := c.GetBool("is_admin")

	trade, err := h.tradeService.GetTrade(tradeID)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid trade ID"})
		return
	}
	if trade == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Trade not found"})
		return
	}

	if !isAdmin && trade.UserID.Hex() != userID {
		c.JSON(http.StatusForbidden, gin.H{"error": "Forbidden (trade belongs to another user)"})
		return
	}

	userObjID, _ := primitive.ObjectIDFromHex(userID)
	metadata := map[string]interface{}{
		"user_id":  userID,
		"trade_id": tradeID,
		"is_admin": isAdmin,
	}
	h.logService.LogAction(userObjID, "GetTrade", "Trade data retrieved", c.ClientIP(), metadata)

	c.JSON(http.StatusOK, trade)
}

// @Summary Handle trade response from MT5
// @Description Processes trade response from MT5 EA
// @Tags Trades
// @Accept json
// @Produce json
// @Param response body service.TradeResponse true "Trade response data"
// @Success 200 {object} map[string]string "Response processed"
// @Failure 400 {object} map[string]string "Invalid JSON or parameters"
// @Failure 500 {object} map[string]string "Server error"
// @Router /api/trade-response [post]
func (h *TradeHandler) HandleTradeResponse(c *gin.Context) {
	var response service.TradeResponse
	if err := c.ShouldBindJSON(&response); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	if err := h.tradeService.HandleTradeResponse(response); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"status": "Response processed"})
}

// @Summary Get all trades
// @Description Retrieves a list of all trades (admin only)
// @Tags Trades
// @Produce json
// @Security BearerAuth
// @Success 200 {array} models.TradeHistory
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 403 {object} map[string]string "Forbidden (non-admin)"
// @Failure 500 {object} map[string]string "Server error"
// @Router /api/v1/admin/trades [get]
func (h *TradeHandler) GetAllTrades(c *gin.Context) {
	isAdmin := c.GetBool("is_admin")
	if !isAdmin {
		c.JSON(http.StatusForbidden, gin.H{"error": "Forbidden (non-admin)"})
		return
	}

	trades, err := h.tradeService.GetAllTrades()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve trades"})
		return
	}

	userID := c.GetString("user_id")
	userObjID, _ := primitive.ObjectIDFromHex(userID)
	metadata := map[string]interface{}{
		"admin_id": userID,
		"count":    len(trades),
	}
	h.logService.LogAction(userObjID, "GetAllTrades", "Retrieved all trades", c.ClientIP(), metadata)

	c.JSON(http.StatusOK, trades)
}

type TradeRequest struct {
	SymbolName string           `json:"symbol_name" binding:"required"`
	TradeType  models.TradeType `json:"trade_type" binding:"required,oneof=BUY SELL"`
	Leverage   int              `json:"leverage" binding:"required,gt=0"`
	Volume     float64          `json:"volume" binding:"required,gt=0"`
	EntryPrice float64          `json:"entry_price" binding:"required,gt=0"`
}
-e 
=== ./api/rules_handlers.go ===

package api

import (
	"fxtrader/internal/models"
	"fxtrader/internal/service"
	"net/http"

	"github.com/gin-gonic/gin"
)

type RuleHandler struct {
	ruleService service.RuleService
}

func NewRuleHandler(ruleService service.RuleService) *RuleHandler {
	return &RuleHandler{ruleService: ruleService}
}

// @Summary Create a new rule
// @Description Adds a new rule to the system (admin only)
// @Tags Rules
// @Accept json
// @Produce json
// @Security BasicAuth
// @Param rule body models.Rule true "Rule data"
// @Success 201 {object} map[string]string "Rule created"
// @Failure 400 {object} map[string]string "Invalid JSON or empty content"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 500 {object} map[string]string "Failed to create rule"
// @Router /admin/rules [post]
func (h *RuleHandler) CreateRule(c *gin.Context) {
	var rule models.Rule
	if err := c.ShouldBindJSON(&rule); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	if rule.Content == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Rule content cannot be empty"})
		return
	}

	if err := h.ruleService.CreateRule(&rule); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create rule"})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"status": "Rule created", "rule_id": rule.ID.Hex()})
}

// @Summary Get rule by ID
// @Description Retrieves details of a rule by ID (admin only)
// @Tags Rules
// @Produce json
// @Security BasicAuth
// @Param id path string true "Rule ID"
// @Success 200 {object} models.Rule
// @Failure 400 {object} map[string]string "Invalid rule ID"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 404 {object} map[string]string "Rule not found"
// @Router /admin/rules/{id} [get]
func (h *RuleHandler) GetRule(c *gin.Context) {
	id := c.Param("id")
	rule, err := h.ruleService.GetRule(id)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid rule ID"})
		return
	}
	if rule == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Rule not found"})
		return
	}
	c.JSON(http.StatusOK, rule)
}

// @Summary Get all rules
// @Description Retrieves a list of all rules (accessible to all users)
// @Tags Rules
// @Produce json
// @Success 200 {array} models.Rule
// @Failure 500 {object} map[string]string "Failed to retrieve rules"
// @Router /rules [get]
func (h *RuleHandler) GetAllRules(c *gin.Context) {
	rules, err := h.ruleService.GetAllRules()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve rules"})
		return
	}
	c.JSON(http.StatusOK, rules)
}

// @Summary Update a rule
// @Description Updates the content of an existing rule (admin only)
// @Tags Rules
// @Accept json
// @Produce json
// @Security BasicAuth
// @Param id path string true "Rule ID"
// @Param rule body models.Rule true "Updated rule data"
// @Success 200 {object} map[string]string "Rule updated"
// @Failure 400 {object} map[string]string "Invalid JSON or empty content"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 500 {object} map[string]string "Failed to update rule"
// @Router /admin/rules/{id} [put]
func (h *RuleHandler) UpdateRule(c *gin.Context) {
	id := c.Param("id")
	var rule models.Rule
	if err := c.ShouldBindJSON(&rule); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	if rule.Content == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Rule content cannot be empty"})
		return
	}

	if err := h.ruleService.UpdateRule(id, &rule); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update rule"})
		return
	}
	c.JSON(http.StatusOK, gin.H{"status": "Rule updated"})
}

// @Summary Delete a rule
// @Description Removes a rule from the system (admin only)
// @Tags Rules
// @Produce json
// @Security BasicAuth
// @Param id path string true "Rule ID"
// @Success 200 {object} map[string]string "Rule deleted"
// @Failure 401 {object} map[string]string "Unauthorized"
// @Failure 500 {object} map[string]string "Failed to delete rule"
// @Router /admin/rules/{id} [delete]
func (h *RuleHandler) DeleteRule(c *gin.Context) {
	id := c.Param("id")
	if err := h.ruleService.DeleteRule(id); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete rule"})
		return
	}
	c.JSON(http.StatusOK, gin.H{"status": "Rule deleted"})
}
-e 
=== ./api/routes.go ===

package api

import (
	"fxtrader/internal/config"
	"fxtrader/internal/middleware"
	"fxtrader/internal/service"
	"fxtrader/internal/ws"
	"os"
	"path/filepath"

	"github.com/gin-gonic/gin"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
)

func SetupRoutes(r *gin.Engine, cfg *config.Config, priceService service.PriceService, userService service.UserService, symbolService service.SymbolService, logService service.LogService, ruleService service.RuleService, tradeService service.TradeService, transactionService service.TransactionService, wsHandler *ws.WebSocketHandler, baseURL string) {
	priceHandler := NewPriceHandler(priceService, logService)
	userHandler := NewUserHandler(userService, logService, cfg)
	symbolHandler := NewSymbolHandler(symbolService, logService)
	logHandler := NewLogHandler(logService)
	ruleHandler := NewRuleHandler(ruleService)
	tradeHandler := NewTradeHandler(tradeService, logService)
	transactionHandler := NewTransactionHandler(transactionService, logService)

	wd, err := os.Getwd()
	if err != nil {
		return
	}

	staticPath := filepath.Join(wd, "..", "..", "static")
	r.Static("/static", staticPath)

	r.GET("/chart", func(c *gin.Context) {
		symbolFile := filepath.Join(staticPath, "symbol.html")
		if _, err := os.Stat(symbolFile); os.IsNotExist(err) {
			c.String(404, "symbol.html not found")
			return
		}
		c.File(symbolFile)
	})

	wdRoot := filepath.Join(wd, "..", "..")
	swaggerJSONPath := filepath.Join(wdRoot, "docs", "swagger.json")
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler, ginSwagger.URL("/docs/swagger.json")))
	r.GET("/docs/swagger.json", func(c *gin.Context) {
		c.File(swaggerJSONPath)
	})

	v1 := r.Group("/api/v1")
	{
		v1.POST("/prices", priceHandler.HandlePrice)
		v1.POST("/users/signup", userHandler.SignupUser)
		v1.POST("/users/login", userHandler.Login)
		v1.GET("/users/:id", middleware.UserAuthMiddleware(userService), userHandler.GetUser)
		v1.GET("/symbols", symbolHandler.GetAllSymbols)
		v1.GET("/symbols/:id", symbolHandler.GetSymbol)
		v1.GET("/rules", ruleHandler.GetAllRules)

		user := v1.Group("/").Use(middleware.UserAuthMiddleware(userService))
		{
			user.POST("/trades", tradeHandler.PlaceTrade)
			user.GET("/trades", tradeHandler.GetUserTrades)
			user.GET("/trades/:id", tradeHandler.GetTrade)
			user.POST("/transactions", transactionHandler.CreateTransaction)
			user.GET("/transactions", transactionHandler.GetUserTransactions)
		}

		admin := v1.Group("/admin").Use(middleware.AdminAuthMiddleware(cfg), middleware.AdminAuthMiddleware(cfg))
		{
			admin.POST("/symbols", symbolHandler.CreateSymbol)
			admin.PUT("/symbols/:id", symbolHandler.UpdateSymbol)
			admin.DELETE("/symbols/:id", symbolHandler.DeleteSymbol)
			admin.GET("/logs", logHandler.GetAllLogs)
			admin.GET("/logs/user/:user_id", logHandler.GetLogsByUser)
			admin.POST("/rules", ruleHandler.CreateRule)
			admin.GET("/rules/:id", ruleHandler.GetRule)
			admin.PUT("/rules/:id", ruleHandler.UpdateRule)
			admin.DELETE("/rules/:id", ruleHandler.DeleteRule)
			admin.GET("/users", userHandler.GetAllUsers)
			admin.GET("/trades", tradeHandler.GetAllTrades)
			admin.GET("/trades/:id", tradeHandler.GetTrade)
			admin.GET("/transactions", transactionHandler.GetAllTransactions)
			admin.GET("/transactions/id/:user_id", transactionHandler.GetTransactionByID)
			admin.GET("/transactions/user/:user_id", transactionHandler.GetTransactionsByUser)
			admin.GET("/transactions/:id", transactionHandler.GetTransactionByID)
			admin.PUT("/transactions/:id", transactionHandler.ReviewTransaction)
		}
	}

	r.GET("/ws", wsHandler.HandleConnection)
}
-e 
=== ./api/user_handlers.go ===

package api

import (
	"fxtrader/internal/config"
	"fxtrader/internal/models"
	"fxtrader/internal/service"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

type SignupRequest struct {
	TelegramID       string  `json:"telegram_id" binding:"required"`
	Username         string  `json:"username"`
	FullName         string  `json:"full_name"`
	PhoneNumber      string  `json:"phone_number"`
	CardNumber       string  `json:"card_number"`
	NationalID       string  `json:"national_id"`
	Citizenship      string  `json:"citizenship"`
	AccountType      string  `json:"account_type"`
	AccountName      string  `json:"account_name"`
	Balance          float64 `json:"balance"`
	Bonus            float64 `json:"bonus"`
	Leverage         int     `json:"leverage"`
	TradeType        string  `json:"trade_type"`
	RegistrationDate string  `json:"registration_date"`
	WalletAddress    string  `json:"wallet_address"`
}

type LoginRequest struct {
	TelegramID string `json:"telegram_id" binding:"required"`
}

type UserHandler struct {
	userService service.UserService
	logService  service.LogService
	cfg         *config.Config
}

func NewUserHandler(userService service.UserService, logService service.LogService, cfg *config.Config) *UserHandler {
	return &UserHandler{userService: userService, logService: logService, cfg: cfg}
}

// @Summary Sign up a new user
// @Description Creates a new user account via Telegram with all UserAccount fields
// @Tags Users
// @Accept json
// @Produce json
// @Param user body SignupRequest true "User account details"
// @Success 201 {object} map[string]interface{} "User created"
// @Failure 400 {object} map[string]string "Invalid JSON"
// @Failure 409 {object} map[string]string "User already exists"
// @Failure 500 {object} map[string]string "Server error"
// @Router /users/signup [post]
func (h *UserHandler) SignupUser(c *gin.Context) {
	var req SignupRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	existingUser, err := h.userService.GetUserByTelegramID(req.TelegramID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check existing user"})
		return
	}
	if existingUser != nil {
		c.JSON(http.StatusConflict, gin.H{"error": "User with this Telegram ID already exists"})
		return
	}

	user := &models.UserAccount{
		ID:               primitive.NewObjectID(),
		TelegramID:       req.TelegramID,
		Username:         req.Username,
		FullName:         req.FullName,
		PhoneNumber:      req.PhoneNumber,
		CardNumber:       req.CardNumber,
		NationalID:       req.NationalID,
		Citizenship:      req.Citizenship,
		AccountType:      req.AccountType,
		AccountName:      req.AccountName,
		Balance:          req.Balance,
		Bonus:            req.Bonus,
		Leverage:         req.Leverage,
		TradeType:        req.TradeType,
		RegistrationDate: req.RegistrationDate,
		WalletAddress:    req.WalletAddress,
	}

	if user.Username == "" {
		user.Username = "user_" + user.TelegramID
	}
	if user.FullName == "" {
		user.FullName = "User " + user.TelegramID
	}
	if user.Citizenship == "" {
		user.Citizenship = "Unknown"
	}
	if user.AccountType == "" {
		user.AccountType = "Standard"
	}
	if user.AccountName == "" {
		user.AccountName = user.Username
	}
	if user.Balance < 0 {
		user.Balance = 0.0
	}
	if user.Bonus < 0 {
		user.Bonus = 0.0
	}
	if user.Leverage <= 0 {
		user.Leverage = 1
	}
	if user.TradeType == "" {
		user.TradeType = "Demo"
	}
	if user.RegistrationDate == "" {
		user.RegistrationDate = time.Now().Format(time.RFC3339)
	}

	if err := h.userService.SignupUser(user); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create user"})
		return
	}

	metadata := map[string]interface{}{
		"username": user.Username,
		"user_id":  user.ID.Hex(),
	}
	h.logService.LogAction(user.ID, "UserSignup", "User signed up via Telegram", c.ClientIP(), metadata)

	c.JSON(http.StatusCreated, gin.H{
		"status":  "User created",
		"user_id": user.ID.Hex(),
		"user":    user,
	})
}

// @Summary User login
// @Description Authenticates a user via Telegram ID
// @Tags Users
// @Accept json
// @Produce json
// @Param credentials body LoginRequest true "Telegram ID"
// @Success 200 {object} map[string]interface{} "User details"
// @Failure 400 {object} map[string]string "Invalid JSON"
// @Failure 401 {object} map[string]string "User not found"
// @Failure 500 {object} map[string]string "Server error"
// @Router /users/login [post]
func (h *UserHandler) Login(c *gin.Context) {
	var req LoginRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	user, err := h.userService.GetUserByTelegramID(req.TelegramID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve user"})
		return
	}
	if user == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not found"})
		return
	}

	metadata := map[string]interface{}{
		"user_id": user.ID.Hex(),
	}
	h.logService.LogAction(user.ID, "UserLogin", "User logged in via Telegram", c.ClientIP(), metadata)

	c.JSON(http.StatusOK, gin.H{
		"status": "Login successful",
		"user":   user,
	})
}

// @Summary Get user by ID
// @Description Retrieves details of a user by their ID
// @Tags Users
// @Produce json
// @Param id path string true "User ID"
// @Success 200 {object} models.UserAccount
// @Failure 400 {object} map[string]string "Invalid user ID"
// @Failure 404 {object} map[string]string "User not found"
// @Router /users/{id} [get]
func (h *UserHandler) GetUser(c *gin.Context) {
	id := c.Param("id")
	user, err := h.userService.GetUser(id)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
		return
	}
	if user == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	metadata := map[string]interface{}{
		"user_id": id,
	}
	h.logService.LogAction(primitive.ObjectID{}, "GetUser", "User data retrieved", c.ClientIP(), metadata)

	c.JSON(http.StatusOK, user)
}

// @Summary Get all users
// @Description Retrieves a list of all users
// @Tags Users
// @Produce json
// @Success 200 {array} models.UserAccount
// @Failure 500 {object} map[string]string "Server error"
// @Router /users [get]
func (h *UserHandler) GetAllUsers(c *gin.Context) {
	users, err := h.userService.GetAllUsers()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve users"})
		return
	}

	metadata := map[string]interface{}{
		"count": len(users),
	}
	h.logService.LogAction(primitive.ObjectID{}, "GetAllUsers", "Retrieved all users", c.ClientIP(), metadata)

	c.JSON(http.StatusOK, users)
}
-e 
=== ./service/transaction_service.go ===

package service

import (
	"errors"
	"fxtrader/internal/models"
	"fxtrader/internal/repository"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type TransactionService interface {
	CreateTransaction(userID string, transaction *models.Transaction) error
	GetTransactionByID(id string) (*models.Transaction, error)
	GetTransactionsByUserID(userID string) ([]*models.Transaction, error)
	GetAllTransactions() ([]*models.Transaction, error)
	ReviewTransaction(id string, status models.TransactionStatus, adminNote string) error
}

type transactionService struct {
	transactionRepo repository.TransactionRepository
	logService      LogService
}

func NewTransactionService(transactionRepo repository.TransactionRepository, logService LogService) TransactionService {
	return &transactionService{
		transactionRepo: transactionRepo,
		logService:      logService,
	}
}

func (s *transactionService) CreateTransaction(userID string, transaction *models.Transaction) error {
	userObjID, err := primitive.ObjectIDFromHex(userID)
	if err != nil {
		return errors.New("invalid user ID")
	}

	if transaction.TransactionType != models.TransactionTypeDeposit && transaction.TransactionType != models.TransactionTypeWithdrawal {
		return errors.New("invalid transaction type")
	}
	if transaction.PaymentMethod != models.PaymentMethodCardToCard && transaction.PaymentMethod != models.PaymentMethodDepositReceipt {
		return errors.New("invalid payment method")
	}
	if transaction.Amount <= 0 {
		return errors.New("amount must be positive")
	}
	if transaction.PaymentMethod == models.PaymentMethodDepositReceipt && transaction.ReceiptImage == "" {
		return errors.New("receipt image required for deposit receipt method")
	}

	transaction.UserID = userObjID
	transaction.Status = models.TransactionStatusPending

	err = s.transactionRepo.SaveTransaction(transaction)
	if err != nil {
		return err
	}

	metadata := map[string]interface{}{
		"transaction_id":   transaction.ID.Hex(),
		"transaction_type": transaction.TransactionType,
		"payment_method":   transaction.PaymentMethod,
		"amount":           transaction.Amount,
	}
	s.logService.LogAction(userObjID, "CreateTransaction", "Transaction requested", "", metadata)

	return nil
}

func (s *transactionService) GetTransactionByID(id string) (*models.Transaction, error) {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, errors.New("invalid transaction ID")
	}
	return s.transactionRepo.GetTransactionByID(objID)
}

func (s *transactionService) GetTransactionsByUserID(userID string) ([]*models.Transaction, error) {
	objID, err := primitive.ObjectIDFromHex(userID)
	if err != nil {
		return nil, errors.New("invalid user ID")
	}
	return s.transactionRepo.GetTransactionsByUserID(objID)
}

func (s *transactionService) GetAllTransactions() ([]*models.Transaction, error) {
	return s.transactionRepo.GetAllTransactions()
}

func (s *transactionService) ReviewTransaction(id string, status models.TransactionStatus, adminNote string) error {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return errors.New("invalid transaction ID")
	}

	transaction, err := s.transactionRepo.GetTransactionByID(objID)
	if err != nil {
		return err
	}
	if transaction == nil {
		return errors.New("transaction not found")
	}

	if status != models.TransactionStatusApproved && status != models.TransactionStatusRejected {
		return errors.New("invalid status; must be APPROVED or REJECTED")
	}

	if transaction.Status != models.TransactionStatusPending {
		return errors.New("transaction already reviewed")
	}

	responseTime := time.Now()
	transaction.Status = status
	transaction.ResponseTime = &responseTime
	transaction.AdminNote = adminNote

	err = s.transactionRepo.UpdateTransaction(objID, transaction)
	if err != nil {
		return err
	}

	metadata := map[string]interface{}{
		"transaction_id": id,
		"status":         status,
		"admin_note":     adminNote,
	}
	s.logService.LogAction(primitive.ObjectID{}, "ReviewTransaction", "Transaction reviewed", "", metadata)

	return nil
}
-e 
=== ./service/rule_service.go ===

package service

import (
	"fxtrader/internal/models"
	"fxtrader/internal/repository"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type RuleService interface {
	CreateRule(rule *models.Rule) error
	GetRule(id string) (*models.Rule, error)
	GetAllRules() ([]*models.Rule, error)
	UpdateRule(id string, rule *models.Rule) error
	DeleteRule(id string) error
}

type ruleService struct {
	ruleRepo repository.RuleRepository
}

func NewRuleService(ruleRepo repository.RuleRepository) RuleService {
	return &ruleService{ruleRepo: ruleRepo}
}

func (s *ruleService) CreateRule(rule *models.Rule) error {
	return s.ruleRepo.SaveRule(rule)
}

func (s *ruleService) GetRule(id string) (*models.Rule, error) {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	return s.ruleRepo.GetRuleByID(objID)
}

func (s *ruleService) GetAllRules() ([]*models.Rule, error) {
	return s.ruleRepo.GetAllRules()
}

func (s *ruleService) UpdateRule(id string, rule *models.Rule) error {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return err
	}
	return s.ruleRepo.UpdateRule(objID, rule)
}

func (s *ruleService) DeleteRule(id string) error {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return err
	}
	return s.ruleRepo.DeleteRule(objID)
}
-e 
=== ./service/trade_service.go ===

package service

import (
	"encoding/json"
	"errors"
	"fmt"
	"fxtrader/internal/models"
	"fxtrader/internal/repository"
	"log"
	"net"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type TradeService interface {
	PlaceTrade(userID, symbolName string, tradeType models.TradeType, leverage int, volume, entryPrice float64) (*models.TradeHistory, error)
	GetTrade(id string) (*models.TradeHistory, error)
	GetTradesByUserID(userID string) ([]*models.TradeHistory, error)
	GetAllTrades() ([]*models.TradeHistory, error)
	HandleTradeResponse(response TradeResponse) error
	StartUDPListener() error
}

type tradeService struct {
	tradeRepo     repository.TradeRepository
	symbolRepo    repository.SymbolRepository
	logService    LogService
	udpConn       *net.UDPConn
	mt5UDPAddr    *net.UDPAddr
	listenUDPAddr *net.UDPAddr
	responseChan  chan TradeResponse
}

func NewTradeService(tradeRepo repository.TradeRepository, symbolRepo repository.SymbolRepository, logService LogService, mt5Host string, mt5Port, listenPort int) (TradeService, error) {
	mt5Addr, err := net.ResolveUDPAddr("udp", fmt.Sprintf("%s:%d", mt5Host, mt5Port))
	if err != nil {
		return nil, err
	}
	listenAddr, err := net.ResolveUDPAddr("udp", fmt.Sprintf(":%d", listenPort))
	if err != nil {
		return nil, err
	}

	return &tradeService{
		tradeRepo:     tradeRepo,
		symbolRepo:    symbolRepo,
		logService:    logService,
		mt5UDPAddr:    mt5Addr,
		listenUDPAddr: listenAddr,
		responseChan:  make(chan TradeResponse, 100),
	}, nil
}

func (s *tradeService) StartUDPListener() error {
	conn, err := net.ListenUDP("udp", s.listenUDPAddr)
	if err != nil {
		return err
	}
	s.udpConn = conn

	go func() {
		defer conn.Close()
		buf := make([]byte, 4096)
		for {
			n, _, err := conn.ReadFromUDP(buf)
			if err != nil {
				log.Printf("UDP read error: %v", err)
				continue
			}

			var response TradeResponse
			if err := json.Unmarshal(buf[:n], &response); err != nil {
				log.Printf("Failed to parse UDP response: %v", err)
				continue
			}

			s.responseChan <- response
		}
	}()

	go func() {
		for response := range s.responseChan {
			if err := s.HandleTradeResponse(response); err != nil {
				log.Printf("Failed to handle trade response: %v", err)
			}
		}
	}()

	return nil
}

func (s *tradeService) PlaceTrade(userID, symbolName string, tradeType models.TradeType, leverage int, volume, entryPrice float64) (*models.TradeHistory, error) {
	userObjID, err := primitive.ObjectIDFromHex(userID)
	if err != nil {
		return nil, errors.New("invalid user ID")
	}

	symbols, err := s.symbolRepo.GetAllSymbols()
	if err != nil {
		return nil, errors.New("failed to fetch symbols")
	}
	var symbol *models.Symbol
	for _, sym := range symbols {
		if sym.SymbolName == symbolName {
			symbol = sym
			break
		}
	}
	if symbol == nil {
		return nil, errors.New("symbol not found")
	}

	if tradeType != models.TradeTypeBuy && tradeType != models.TradeTypeSell {
		return nil, errors.New("invalid trade type")
	}
	if volume < symbol.MinLot || volume > symbol.MaxLot {
		return nil, errors.New("volume out of allowed range")
	}
	if leverage > symbol.Leverage {
		return nil, errors.New("leverage exceeds symbol limit")
	}

	trade := &models.TradeHistory{
		ID:         primitive.NewObjectID(),
		UserID:     userObjID,
		SymbolName: symbolName,
		TradeType:  tradeType,
		Leverage:   leverage,
		Volume:     volume,
		EntryPrice: entryPrice,
		OpenTime:   time.Now(),
		Status:     models.TradeStatusPending,
	}

	err = s.sendTradeToMT5(trade)
	if err != nil {
		return nil, err
	}

	err = s.tradeRepo.SaveTrade(trade)
	if err != nil {
		return nil, err
	}

	metadata := map[string]interface{}{
		"trade_id":    trade.ID.Hex(),
		"symbol_name": symbolName,
		"trade_type":  tradeType,
		"leverage":    leverage,
		"volume":      volume,
		"entry_price": entryPrice,
	}
	s.logService.LogAction(userObjID, "PlaceTrade", "Trade order placed", "", metadata)

	return trade, nil
}

func (s *tradeService) sendTradeToMT5(trade *models.TradeHistory) error {
	tradeRequest := map[string]interface{}{
		"trade_id":    trade.ID.Hex(),
		"user_id":     trade.UserID.Hex(),
		"symbol":      trade.SymbolName,
		"trade_type":  trade.TradeType,
		"leverage":    trade.Leverage,
		"volume":      trade.Volume,
		"entry_price": trade.EntryPrice,
		"timestamp":   trade.OpenTime.Unix(),
	}

	data, err := json.Marshal(tradeRequest)
	if err != nil {
		return err
	}

	conn, err := net.DialUDP("udp", nil, s.mt5UDPAddr)
	if err != nil {
		return errors.New("failed to connect to MT5 UDP")
	}
	defer conn.Close()

	_, err = conn.Write(data)
	if err != nil {
		return errors.New("failed to send trade request")
	}

	return nil
}

func (s *tradeService) HandleTradeResponse(response TradeResponse) error {
	tradeID, err := primitive.ObjectIDFromHex(response.TradeID)
	if err != nil {
		return errors.New("invalid trade ID")
	}

	trade, err := s.tradeRepo.GetTradeByID(tradeID)
	if err != nil {
		return err
	}
	if trade == nil {
		return errors.New("trade not found")
	}

	if response.Status == "MATCHED" {
		trade.Status = models.TradeStatusOpen
		trade.ID, _ = primitive.ObjectIDFromHex(response.MatchedTradeID)
	} else if response.Status == "PENDING" {
		trade.Status = models.TradeStatusPending
	} else {
		trade.Status = models.TradeStatusClosed
	}

	err = s.tradeRepo.SaveTrade(trade)
	if err != nil {
		return err
	}

	metadata := map[string]interface{}{
		"trade_id":         response.TradeID,
		"status":           response.Status,
		"matched_trade_id": response.MatchedTradeID,
	}
	s.logService.LogAction(trade.UserID, "TradeResponse", "Trade status updated", "", metadata)

	return nil
}

func (s *tradeService) GetTrade(id string) (*models.TradeHistory, error) {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	return s.tradeRepo.GetTradeByID(objID)
}

func (s *tradeService) GetTradesByUserID(userID string) ([]*models.TradeHistory, error) {
	objID, err := primitive.ObjectIDFromHex(userID)
	if err != nil {
		return nil, err
	}
	return s.tradeRepo.GetTradesByUserID(objID)
}

func (s *tradeService) GetAllTrades() ([]*models.TradeHistory, error) {
	return s.tradeRepo.GetAllTrades()
}

type TradeResponse struct {
	TradeID        string `json:"trade_id"`
	UserID         string `json:"user_id"`
	Status         string `json:"status"`
	MatchedTradeID string `json:"matched_trade_id"`
	Timestamp      int64  `json:"timestamp"`
}
-e 
=== ./service/price_service.go ===

package service

import (
	"fxtrader/internal/models"
	"fxtrader/internal/repository"
	"fxtrader/internal/ws"
	"log"
)

type PriceService interface {
	ProcessPrice(data *models.PriceData) error
}

type priceService struct {
	repo repository.PriceRepository
	hub  *ws.Hub
}

func NewPriceService(repo repository.PriceRepository, hub *ws.Hub) PriceService {
	return &priceService{
		repo: repo,
		hub:  hub,
	}
}

func (s *priceService) ProcessPrice(data *models.PriceData) error {
	if err := s.repo.SavePrice(data); err != nil {
		return err
	}

	s.hub.BroadcastPrice(data)
	log.Printf("Price broadcast: %s Ask: %.5f Bid: %.5f", data.Symbol, data.Ask, data.Bid)

	return nil
}
-e 
=== ./service/user_service.go ===

package service

// package service
import (
	"fxtrader/internal/models"
	"fxtrader/internal/repository"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type UserService interface {
	SignupUser(user *models.UserAccount) error
	GetUser(id string) (*models.UserAccount, error)
	GetUserByTelegramID(telegramID string) (*models.UserAccount, error)
	GetAllUsers() ([]*models.UserAccount, error)
}

type userService struct {
	userRepo repository.UserRepository
}

func NewUserService(userRepo repository.UserRepository) UserService {
	return &userService{userRepo: userRepo}
}

func (s *userService) SignupUser(user *models.UserAccount) error {
	if user.ID.IsZero() {
		user.ID = primitive.NewObjectID()
	}
	if user.RegistrationDate == "" {
		user.RegistrationDate = time.Now().Format(time.RFC3339)
	}
	return s.userRepo.SaveUser(user)
}

func (s *userService) GetUser(id string) (*models.UserAccount, error) {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	return s.userRepo.GetUserByID(objID)
}

func (s *userService) GetUserByTelegramID(telegramID string) (*models.UserAccount, error) {
	return s.userRepo.GetUserByTelegramID(telegramID)
}

func (s *userService) GetAllUsers() ([]*models.UserAccount, error) {
	return s.userRepo.GetAllUsers()
}
-e 
=== ./service/log_service.go ===

package service

import (
	"fxtrader/internal/models"
	"fxtrader/internal/repository"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type LogService interface {
	LogAction(userID primitive.ObjectID, action, description, ipAddress string, metadata map[string]interface{}) error
	GetAllLogs() ([]*models.LogEntry, error)
	GetLogsByUserID(userID string) ([]*models.LogEntry, error)
}

type logService struct {
	logRepo repository.LogRepository
}

func NewLogService(logRepo repository.LogRepository) LogService {
	return &logService{logRepo: logRepo}
}

func (s *logService) LogAction(userID primitive.ObjectID, action, description, ipAddress string, metadata map[string]interface{}) error {
	logEntry := &models.LogEntry{
		UserID:      userID,
		Action:      action,
		Description: description,
		IPAddress:   ipAddress,
		Metadata:    metadata,
	}
	return s.logRepo.SaveLog(logEntry)
}

func (s *logService) GetAllLogs() ([]*models.LogEntry, error) {
	return s.logRepo.GetAllLogs()
}

func (s *logService) GetLogsByUserID(userID string) ([]*models.LogEntry, error) {
	objID, err := primitive.ObjectIDFromHex(userID)
	if err != nil {
		return nil, err
	}
	return s.logRepo.GetLogsByUserID(objID)
}
-e 
=== ./service/symbo_service.go ===

package service

import (
	"fxtrader/internal/models"
	"fxtrader/internal/repository"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type SymbolService interface {
	CreateSymbol(symbol *models.Symbol) error
	GetSymbol(id string) (*models.Symbol, error)
	GetAllSymbols() ([]*models.Symbol, error)
	UpdateSymbol(id string, symbol *models.Symbol) error
	DeleteSymbol(id string) error
}

type symbolService struct {
	symbolRepo repository.SymbolRepository
}

func NewSymbolService(symbolRepo repository.SymbolRepository) SymbolService {
	return &symbolService{symbolRepo: symbolRepo}
}

func (s *symbolService) CreateSymbol(symbol *models.Symbol) error {
	return s.symbolRepo.SaveSymbol(symbol)
}

func (s *symbolService) GetSymbol(id string) (*models.Symbol, error) {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	return s.symbolRepo.GetSymbolByID(objID)
}

func (s *symbolService) GetAllSymbols() ([]*models.Symbol, error) {
	return s.symbolRepo.GetAllSymbols()
}

func (s *symbolService) UpdateSymbol(id string, symbol *models.Symbol) error {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return err
	}
	return s.symbolRepo.UpdateSymbol(objID, symbol)
}

func (s *symbolService) DeleteSymbol(id string) error {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return err
	}
	return s.symbolRepo.DeleteSymbol(objID)
}
