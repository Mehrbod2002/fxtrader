-e 
=== ./cmd/server/main.go ===

package main

import (
	"context"
	"fmt"
	"fxtrader/internal/api"
	"fxtrader/internal/config"
	"fxtrader/internal/middleware"
	"fxtrader/internal/repository"
	"fxtrader/internal/service"
	"fxtrader/internal/ws"
	"log"
	"os"
	"time"

	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

func main() {
	cfg, err := config.Load()
	if err != nil {
		log.Fatalf("Failed to load config: %v", err)
	}

	mongoURI := os.Getenv("MONGO_URI")
	if mongoURI == "" {
		mongoURI = "mongodb://localhost:27017"
	}
	client, err := mongo.Connect(context.Background(), options.Client().ApplyURI(mongoURI))
	if err != nil {
		log.Fatalf("Failed to connect to MongoDB: %v", err)
	}
	defer client.Disconnect(context.Background())

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	if err := client.Ping(ctx, nil); err != nil {
		log.Fatalf("Failed to ping MongoDB: %v", err)
	}

	baseURL := os.Getenv("BASE_URL")
	if baseURL == "" {
		baseURL = fmt.Sprintf("http://localhost:%d", cfg.Port)
	}

	hub := ws.NewHub()
	go hub.Run()

	wsHandler := ws.NewWebSocketHandler(hub)

	priceRepo := repository.NewPriceRepository()
	priceService := service.NewPriceService(priceRepo, hub)

	userRepo := repository.NewUserRepository(client, "fxtrader", "users")
	userService := service.NewUserService(userRepo)

	r := gin.New()
	r.Use(gin.Recovery())
	r.Use(middleware.LoggerMiddleware())

	api.SetupRoutes(r, priceService, userService, wsHandler, baseURL)

	addr := fmt.Sprintf(":%d", cfg.Port)
	log.Printf("Starting server on %s", addr)
	log.Printf("WebSocket endpoint available at ws://%s/ws", baseURL)
	log.Printf("Chart endpoint available at http://%s/chart?symbol=SYMBOL", baseURL)

	if err := r.Run(addr); err != nil {
		log.Fatalf("Failed to start server: %v", err)
	}
}
-e 
=== ./go.mod ===

module fxtrader

go 1.23.4

require (
	github.com/gin-gonic/gin v1.10.0
	github.com/google/uuid v1.6.0
	github.com/gorilla/websocket v1.5.3
	github.com/joho/godotenv v1.5.1
	go.mongodb.org/mongo-driver v1.17.3
)

require (
	github.com/bytedance/sonic v1.11.6 // indirect
	github.com/bytedance/sonic/loader v0.1.1 // indirect
	github.com/cloudwego/base64x v0.1.4 // indirect
	github.com/cloudwego/iasm v0.2.0 // indirect
	github.com/gabriel-vasile/mimetype v1.4.3 // indirect
	github.com/gin-contrib/sse v0.1.0 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.20.0 // indirect
	github.com/goccy/go-json v0.10.2 // indirect
	github.com/golang/snappy v0.0.4 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/compress v1.16.7 // indirect
	github.com/klauspost/cpuid/v2 v2.2.7 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/montanaflynn/stats v0.7.1 // indirect
	github.com/pelletier/go-toml/v2 v2.2.2 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.2.12 // indirect
	github.com/xdg-go/pbkdf2 v1.0.0 // indirect
	github.com/xdg-go/scram v1.1.2 // indirect
	github.com/xdg-go/stringprep v1.0.4 // indirect
	github.com/youmark/pkcs8 v0.0.0-20240726163527-a2c0da244d78 // indirect
	golang.org/x/arch v0.8.0 // indirect
	golang.org/x/crypto v0.26.0 // indirect
	golang.org/x/net v0.25.0 // indirect
	golang.org/x/sync v0.8.0 // indirect
	golang.org/x/sys v0.23.0 // indirect
	golang.org/x/text v0.17.0 // indirect
	google.golang.org/protobuf v1.34.1 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)
-e 
=== ./internal/middleware/logger.go ===

package middleware

import (
	"fmt"
	"time"

	"github.com/gin-gonic/gin"
)

func LoggerMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		start := time.Now()
		path := c.Request.URL.Path
		method := c.Request.Method

		c.Next()

		latency := time.Since(start)
		status := c.Writer.Status()
		fmt.Printf("[%s] %s %s %d %v\n", time.Now().Format(time.RFC3339), method, path, status, latency)
	}
}
-e 
=== ./internal/repository/user_repository.go ===

package repository

import (
	"context"
	"fxtrader/internal/models"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

type UserRepository interface {
	SaveUser(user *models.UserAccount) error
	GetUserByID(id primitive.ObjectID) (*models.UserAccount, error)
}

type MongoUserRepository struct {
	collection *mongo.Collection
}

func NewUserRepository(client *mongo.Client, dbName, collectionName string) UserRepository {
	collection := client.Database(dbName).Collection(collectionName)
	return &MongoUserRepository{collection: collection}
}

func (r *MongoUserRepository) SaveUser(user *models.UserAccount) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	_, err := r.collection.InsertOne(ctx, user)
	return err
}

func (r *MongoUserRepository) GetUserByID(id primitive.ObjectID) (*models.UserAccount, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var user models.UserAccount
	err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&user)
	if err == mongo.ErrNoDocuments {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return &user, nil
}
-e 
=== ./internal/repository/symbol_repository.go ===

package repository

import (
	"context"
	"fxtrader/internal/models"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

type SymbolRepository interface {
	SaveSymbol(symbol *models.Symbol) error
	GetSymbolByID(id primitive.ObjectID) (*models.Symbol, error)
	GetAllSymbols() ([]*models.Symbol, error)
	UpdateSymbol(id primitive.ObjectID, symbol *models.Symbol) error
	DeleteSymbol(id primitive.ObjectID) error
}

type MongoSymbolRepository struct {
	collection *mongo.Collection
}

func NewSymbolRepository(client *mongo.Client, dbName, collectionName string) SymbolRepository {
	collection := client.Database(dbName).Collection(collectionName)
	return &MongoSymbolRepository{collection: collection}
}

func (r *MongoSymbolRepository) SaveSymbol(symbol *models.Symbol) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	symbol.ID = primitive.NewObjectID()
	symbol.CreatedAt = time.Now()
	symbol.UpdatedAt = time.Now()
	_, err := r.collection.InsertOne(ctx, symbol)
	return err
}

func (r *MongoSymbolRepository) GetSymbolByID(id primitive.ObjectID) (*models.Symbol, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var symbol models.Symbol
	err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&symbol)
	if err == mongo.ErrNoDocuments {
		return nil, nil
	}
	return &symbol, err
}

func (r *MongoSymbolRepository) GetAllSymbols() ([]*models.Symbol, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var symbols []*models.Symbol
	cursor, err := r.collection.Find(ctx, bson.M{})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)
	if err := cursor.All(ctx, &symbols); err != nil {
		return nil, err
	}
	return symbols, nil
}

func (r *MongoSymbolRepository) UpdateSymbol(id primitive.ObjectID, symbol *models.Symbol) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	symbol.UpdatedAt = time.Now()
	update := bson.M{"$set": symbol}
	_, err := r.collection.UpdateOne(ctx, bson.M{"_id": id}, update)
	return err
}

func (r *MongoSymbolRepository) DeleteSymbol(id primitive.ObjectID) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	_, err := r.collection.DeleteOne(ctx, bson.M{"_id": id})
	return err
}
-e 
=== ./internal/repository/price_repository.go ===

package repository

import (
	"fxtrader/internal/models"
	"sync"
)

type PriceRepository interface {
	SavePrice(data *models.PriceData) error
}

type InMemoryPriceRepository struct {
	prices []*models.PriceData
	mu     sync.Mutex
}

func NewPriceRepository() PriceRepository {
	return &InMemoryPriceRepository{
		prices: make([]*models.PriceData, 0),
	}
}

func (r *InMemoryPriceRepository) SavePrice(data *models.PriceData) error {
	r.mu.Lock()
	defer r.mu.Unlock()
	r.prices = append(r.prices, data)
	return nil
}
-e 
=== ./internal/config/config.go ===

package config

import (
	"os"
	"strconv"

	"github.com/joho/godotenv"
)

type Config struct {
	Address  string
	Port     int
	BaseURL  string
	MongoURI string
}

func Load() (*Config, error) {
	_ = godotenv.Load()

	portStr := os.Getenv("PORT")
	if portStr == "" {
		portStr = "8080"
	}

	port, err := strconv.Atoi(portStr)
	if err != nil {
		return nil, err
	}

	address := os.Getenv("ADDRESS")
	if address == "" {
		address = "0.0.0.0"
	}

	baseURL := os.Getenv("BASE_URL")
	if baseURL == "" {
		baseURL = "http://localhost:" + portStr
	}

	mongoURI := os.Getenv("MONGO_URI")
	if mongoURI == "" {
		mongoURI = "mongodb://localhost:27017"
	}

	return &Config{
		Address:  address,
		Port:     port,
		BaseURL:  baseURL,
		MongoURI: mongoURI,
	}, nil
}
-e 
=== ./internal/models/user.go ===

package models

import "go.mongodb.org/mongo-driver/bson/primitive"

type UserAccount struct {
	ID               primitive.ObjectID `json:"_id,omitempty" bson:"_id,omitempty"`
	Username         string             `json:"username" bson:"username"`
	FullName         string             `json:"full_name" bson:"full_name"`
	PhoneNumber      string             `json:"phone_number" bson:"phone_number"`
	CardNumber       string             `json:"card_number" bson:"card_number"`
	NationalID       string             `json:"national_id" bson:"national_id"`
	Citizenship      string             `json:"citizenship" bson:"citizenship"`
	AccountType      string             `json:"account_type" bson:"account_type"`
	AccountName      string             `json:"account_name" bson:"account_name"`
	Balance          float64            `json:"balance" bson:"balance"`
	Bonus            float64            `json:"bonus" bson:"bonus"`
	Leverage         int                `json:"leverage" bson:"leverage"`
	TradeType        string             `json:"trade_type" bson:"trade_type"`
	RegistrationDate string             `json:"registration_date" bson:"registration_date"`
	WalletAddress    string             `json:"wallet_address" bson:"wallet_address"`
	TelegramID       string             `json:"telegram_id" bson:"telegram_id"`
}
-e 
=== ./internal/models/symbol.go ===

package models

import (
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type Symbol struct {
	ID             primitive.ObjectID `json:"_id,omitempty" bson:"_id,omitempty"`
	SymbolName     string             `json:"symbol_name" bson:"symbol_name"`
	DisplayName    string             `json:"display_name" bson:"display_name"`
	Category       string             `json:"category" bson:"category"`
	DeniedAccounts []string           `json:"denied_accounts" bson:"denied_accounts"`
	Leverage       int                `json:"leverage" bson:"leverage"`
	MinLot         float64            `json:"min_lot" bson:"min_lot"`
	MaxLot         float64            `json:"max_lot" bson:"max_lot"`
	Spread         float64            `json:"spread" bson:"spread"`
	Commission     float64            `json:"commission" bson:"commission"`
	TradingHours   TradingHours       `json:"trading_hours" bson:"trading_hours"`
	IsTradingOpen  bool               `json:"is_trading_open" bson:"is_trading_open"`
	CreatedAt      time.Time          `json:"created_at" bson:"created_at"`
	UpdatedAt      time.Time          `json:"updated_at" bson:"updated_at"`
}

type TradingHours struct {
	Unlimited bool      `json:"unlimited" bson:"unlimited"`
	OpenTime  time.Time `json:"open_time,omitempty" bson:"open_time,omitempty"`
	CloseTime time.Time `json:"close_time,omitempty" bson:"close_time,omitempty"`
}
-e 
=== ./internal/models/client.go ===

package models

import (
	"sync"

	"github.com/gorilla/websocket"
)

type Client struct {
	ID      string
	Conn    *websocket.Conn
	Send    chan *PriceData
	Symbols map[string]bool
	mu      sync.RWMutex
}

func NewClient(id string, conn *websocket.Conn) *Client {
	return &Client{
		ID:      id,
		Conn:    conn,
		Send:    make(chan *PriceData, 256),
		Symbols: make(map[string]bool),
	}
}

func (c *Client) Subscribe(symbol string) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.Symbols[symbol] = true
}

func (c *Client) Unsubscribe(symbol string) {
	c.mu.Lock()
	defer c.mu.Unlock()
	delete(c.Symbols, symbol)
}

func (c *Client) IsSubscribed(symbol string) bool {
	c.mu.RLock()
	defer c.mu.RUnlock()
	_, ok := c.Symbols[symbol]
	return ok
}

func (c *Client) Close() {
	c.Conn.Close()
	close(c.Send)
}

type SocketMessage struct {
	Action string `json:"action"`
	Symbol string `json:"symbol"`
}

type SubscriptionResponse struct {
	Status  string   `json:"status"`
	Message string   `json:"message"`
	Symbols []string `json:"symbols,omitempty"`
}

type ErrorResponse struct {
	Error string `json:"error"`
}
-e 
=== ./internal/models/price.go ===

package models

type PriceData struct {
	Symbol    string  `json:"symbol"`
	Ask       float64 `json:"ask"`
	Bid       float64 `json:"bid"`
	Timestamp int64   `json:"timestamp"`
}
-e 
=== ./internal/api/symbol_handlers.go ===

package api

import (
	"fxtrader/internal/models"
	"fxtrader/internal/service"
	"net/http"

	"github.com/gin-gonic/gin"
)

type SymbolHandler struct {
	symbolService service.SymbolService
}

func NewSymbolHandler(symbolService service.SymbolService) *SymbolHandler {
	return &SymbolHandler{symbolService: symbolService}
}

func (h *SymbolHandler) CreateSymbol(c *gin.Context) {
	var symbol models.Symbol
	if err := c.ShouldBindJSON(&symbol); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	if err := h.symbolService.CreateSymbol(&symbol); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create symbol"})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"status": "Symbol created", "symbol_id": symbol.ID.Hex()})
}

func (h *SymbolHandler) GetSymbol(c *gin.Context) {
	id := c.Param("id")
	symbol, err := h.symbolService.GetSymbol(id)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid symbol ID"})
		return
	}
	if symbol == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Symbol not found"})
		return
	}
	c.JSON(http.StatusOK, symbol)
}

func (h *SymbolHandler) GetAllSymbols(c *gin.Context) {
	symbols, err := h.symbolService.GetAllSymbols()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve symbols"})
		return
	}
	c.JSON(http.StatusOK, symbols)
}

func (h *SymbolHandler) UpdateSymbol(c *gin.Context) {
	id := c.Param("id")
	var symbol models.Symbol
	if err := c.ShouldBindJSON(&symbol); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	if err := h.symbolService.UpdateSymbol(id, &symbol); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update symbol"})
		return
	}
	c.JSON(http.StatusOK, gin.H{"status": "Symbol updated"})
}

func (h *SymbolHandler) DeleteSymbol(c *gin.Context) {
	id := c.Param("id")
	if err := h.symbolService.DeleteSymbol(id); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete symbol"})
		return
	}
	c.JSON(http.StatusOK, gin.H{"status": "Symbol deleted"})
}
-e 
=== ./internal/api/handlers.go ===

package api

import (
	"fxtrader/internal/models"
	"fxtrader/internal/service"
	"net/http"

	"github.com/gin-gonic/gin"
)

type PriceHandler struct {
	priceService service.PriceService
}

func NewPriceHandler(priceService service.PriceService) *PriceHandler {
	return &PriceHandler{priceService: priceService}
}

func (h *PriceHandler) HandlePrice(c *gin.Context) {
	var priceData models.PriceData
	if err := c.ShouldBindJSON(&priceData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	if err := h.priceService.ProcessPrice(&priceData); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to process price"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"status": "Price received"})
}
-e 
=== ./internal/api/routes.go ===

package api

import (
	"fxtrader/internal/service"
	"fxtrader/internal/ws"
	"os"
	"path/filepath"

	"github.com/gin-gonic/gin"
)

func SetupRoutes(r *gin.Engine, priceService service.PriceService, userService service.UserService, wsHandler *ws.WebSocketHandler, baseURL string) {
	priceHandler := NewPriceHandler(priceService)
	userHandler := NewUserHandler(userService)

	wd, err := os.Getwd()
	if err != nil {
		return
	}

	staticPath := filepath.Join(wd, "..", "..", "static")

	r.Static("/static", staticPath)

	r.GET("/chart", func(c *gin.Context) {
		symbolFile := filepath.Join(staticPath, "symbol.html")
		if _, err := os.Stat(symbolFile); os.IsNotExist(err) {
			c.String(404, "symbol.html not found")
			return
		}
		c.File(symbolFile)
	})

	v1 := r.Group("/api")
	{
		v1.POST("/prices", priceHandler.HandlePrice)
		v1.POST("/users/signup", userHandler.SignupUser)
		v1.GET("/users/:id", userHandler.GetUser)
	}

	r.GET("/ws", wsHandler.HandleConnection)
}
-e 
=== ./internal/api/user_handlers.go ===

package api

import (
	"fxtrader/internal/models"
	"fxtrader/internal/service"
	"net/http"

	"github.com/gin-gonic/gin"
)

type UserHandler struct {
	userService service.UserService
}

func NewUserHandler(userService service.UserService) *UserHandler {
	return &UserHandler{userService: userService}
}

func (h *UserHandler) SignupUser(c *gin.Context) {
	var user models.UserAccount
	if err := c.ShouldBindJSON(&user); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	if err := h.userService.SignupUser(&user); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create user"})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"status": "User created", "user_id": user.ID.Hex()})
}

func (h *UserHandler) GetUser(c *gin.Context) {
	id := c.Param("id")
	user, err := h.userService.GetUser(id)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
		return
	}
	if user == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	c.JSON(http.StatusOK, user)
}
-e 
=== ./internal/service/price_service.go ===

package service

import (
	"fxtrader/internal/models"
	"fxtrader/internal/repository"
	"fxtrader/internal/ws"
	"log"
)

type PriceService interface {
	ProcessPrice(data *models.PriceData) error
}

type priceService struct {
	repo repository.PriceRepository
	hub  *ws.Hub
}

func NewPriceService(repo repository.PriceRepository, hub *ws.Hub) PriceService {
	return &priceService{
		repo: repo,
		hub:  hub,
	}
}

func (s *priceService) ProcessPrice(data *models.PriceData) error {
	if err := s.repo.SavePrice(data); err != nil {
		return err
	}

	s.hub.BroadcastPrice(data)
	log.Printf("Price broadcast: %s Ask: %.5f Bid: %.5f", data.Symbol, data.Ask, data.Bid)

	return nil
}
-e 
=== ./internal/service/user_service.go ===

package service

import (
	"fxtrader/internal/models"
	"fxtrader/internal/repository"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type UserService interface {
	SignupUser(user *models.UserAccount) error
	GetUser(id string) (*models.UserAccount, error)
}

type userService struct {
	userRepo repository.UserRepository
}

func NewUserService(userRepo repository.UserRepository) UserService {
	return &userService{userRepo: userRepo}
}

func (s *userService) SignupUser(user *models.UserAccount) error {
	user.ID = primitive.NewObjectID()
	user.RegistrationDate = time.Now().Format(time.RFC3339)
	return s.userRepo.SaveUser(user)
}

func (s *userService) GetUser(id string) (*models.UserAccount, error) {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	return s.userRepo.GetUserByID(objID)
}
-e 
=== ./internal/service/symbo_service.go ===

package service

import (
	"fxtrader/internal/models"
	"fxtrader/internal/repository"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type SymbolService interface {
	CreateSymbol(symbol *models.Symbol) error
	GetSymbol(id string) (*models.Symbol, error)
	GetAllSymbols() ([]*models.Symbol, error)
	UpdateSymbol(id string, symbol *models.Symbol) error
	DeleteSymbol(id string) error
}

type symbolService struct {
	symbolRepo repository.SymbolRepository
}

func NewSymbolService(symbolRepo repository.SymbolRepository) SymbolService {
	return &symbolService{symbolRepo: symbolRepo}
}

func (s *symbolService) CreateSymbol(symbol *models.Symbol) error {
	return s.symbolRepo.SaveSymbol(symbol)
}

func (s *symbolService) GetSymbol(id string) (*models.Symbol, error) {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	return s.symbolRepo.GetSymbolByID(objID)
}

func (s *symbolService) GetAllSymbols() ([]*models.Symbol, error) {
	return s.symbolRepo.GetAllSymbols()
}

func (s *symbolService) UpdateSymbol(id string, symbol *models.Symbol) error {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return err
	}
	return s.symbolRepo.UpdateSymbol(objID, symbol)
}

func (s *symbolService) DeleteSymbol(id string) error {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return err
	}
	return s.symbolRepo.DeleteSymbol(objID)
}
-e 
=== ./internal/ws/handler.go ===

package ws

import (
	"encoding/json"
	"fxtrader/internal/models"
	"log"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/gorilla/websocket"
)

const (
	writeWait = 10 * time.Second

	pongWait = 60 * time.Second

	pingPeriod = (pongWait * 9) / 10

	maxMessageSize = 512
)

var upgrader = websocket.Upgrader{
	ReadBufferSize:  1024,
	WriteBufferSize: 1024,
	CheckOrigin: func(r *http.Request) bool {
		return true
	},
}

type WebSocketHandler struct {
	hub *Hub
}

func NewWebSocketHandler(hub *Hub) *WebSocketHandler {
	return &WebSocketHandler{hub: hub}
}

func (h *WebSocketHandler) HandleConnection(c *gin.Context) {
	conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
	if err != nil {
		log.Printf("Error upgrading connection: %v", err)
		return
	}

	client := h.hub.RegisterClient(conn)

	go h.readPump(client)
	go h.writePump(client)
}

func (h *WebSocketHandler) readPump(client *models.Client) {
	defer func() {
		h.hub.UnregisterClient(client)
	}()

	client.Conn.SetReadLimit(maxMessageSize)
	client.Conn.SetReadDeadline(time.Now().Add(pongWait))
	client.Conn.SetPongHandler(func(string) error {
		client.Conn.SetReadDeadline(time.Now().Add(pongWait))
		return nil
	})

	for {
		_, message, err := client.Conn.ReadMessage()
		if err != nil {
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				log.Printf("error: %v", err)
			}
			break
		}

		var socketMsg models.SocketMessage
		if err := json.Unmarshal(message, &socketMsg); err != nil {
			response := models.ErrorResponse{Error: "Invalid message format"}
			client.Conn.WriteJSON(response)
			continue
		}

		switch socketMsg.Action {
		case "subscribe":
			client.Subscribe(socketMsg.Symbol)

			var symbols []string
			for symbol := range client.Symbols {
				symbols = append(symbols, symbol)
			}

			response := models.SubscriptionResponse{
				Status:  "success",
				Message: "Subscribed to " + socketMsg.Symbol,
				Symbols: symbols,
			}
			client.Conn.WriteJSON(response)

		case "unsubscribe":
			client.Unsubscribe(socketMsg.Symbol)

			var symbols []string
			for symbol := range client.Symbols {
				symbols = append(symbols, symbol)
			}

			response := models.SubscriptionResponse{
				Status:  "success",
				Message: "Unsubscribed from " + socketMsg.Symbol,
				Symbols: symbols,
			}
			client.Conn.WriteJSON(response)

		default:
			response := models.ErrorResponse{Error: "Unknown action"}
			client.Conn.WriteJSON(response)
		}
	}
}

func (h *WebSocketHandler) writePump(client *models.Client) {
	ticker := time.NewTicker(pingPeriod)
	defer func() {
		ticker.Stop()
		client.Conn.Close()
	}()

	for {
		select {
		case price, ok := <-client.Send:
			client.Conn.SetWriteDeadline(time.Now().Add(writeWait))
			if !ok {
				client.Conn.WriteMessage(websocket.CloseMessage, []byte{})
				return
			}

			err := client.Conn.WriteJSON(price)
			if err != nil {
				return
			}

		case <-ticker.C:
			client.Conn.SetWriteDeadline(time.Now().Add(writeWait))
			if err := client.Conn.WriteMessage(websocket.PingMessage, nil); err != nil {
				return
			}
		}
	}
}
-e 
=== ./internal/ws/hub.go ===

package ws

import (
	"fxtrader/internal/models"
	"log"
	"sync"

	"github.com/google/uuid"
	"github.com/gorilla/websocket"
)

type Hub struct {
	clients map[string]*models.Client

	register chan *models.Client

	unregister chan *models.Client

	broadcast chan *models.PriceData

	mu sync.RWMutex
}

func NewHub() *Hub {
	return &Hub{
		clients:    make(map[string]*models.Client),
		register:   make(chan *models.Client),
		unregister: make(chan *models.Client),
		broadcast:  make(chan *models.PriceData),
	}
}

func (h *Hub) Run() {
	for {
		select {
		case client := <-h.register:
			h.mu.Lock()
			h.clients[client.ID] = client
			h.mu.Unlock()

		case client := <-h.unregister:
			h.mu.Lock()
			if _, ok := h.clients[client.ID]; ok {
				delete(h.clients, client.ID)
				client.Close()
			}
			h.mu.Unlock()

		case price := <-h.broadcast:
			h.mu.RLock()
			for _, client := range h.clients {
				if client.IsSubscribed(price.Symbol) {
					select {
					case client.Send <- price:
					default:
						log.Printf("Client %s buffer full, skipping message", client.ID)
					}
				}
			}
			h.mu.RUnlock()
		}
	}
}

func (h *Hub) RegisterClient(conn *websocket.Conn) *models.Client {
	clientID := uuid.New().String()
	client := models.NewClient(clientID, conn)
	h.register <- client
	return client
}

func (h *Hub) UnregisterClient(client *models.Client) {
	h.unregister <- client
}

func (h *Hub) BroadcastPrice(data *models.PriceData) {
	h.broadcast <- data
}

func (h *Hub) GetClientCount() int {
	h.mu.RLock()
	defer h.mu.RUnlock()
	return len(h.clients)
}